<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>FamilyChat Pro | P2P Secure Messenger</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

    <style>
        :root {
            --primary: #00a884;
            --primary-dark: #008f6f;
            --bg-main: #d1d7db;
            --bg-panel: #ffffff;
            --bg-chat: #efeae2;
            --text-main: #111b21;
            --text-sub: #667781;
            --incoming: #ffffff;
            --outgoing: #d9fdd3;
            --danger: #ef5350;
            --success: #25d366;
            --warning: #ff9800;
            --shadow-card: 0 4px 18px rgba(0,0,0,0.1);
            --header-height: 60px;
            --sidebar-width: 380px;
            --border-radius: 12px;
        }

        [data-theme="dark"] {
            --primary: #00a884;
            --primary-dark: #02906f;
            --bg-main: #0b141a;
            --bg-panel: #202c33;
            --bg-chat: #0b141a;
            --text-main: #e9edef;
            --text-sub: #8696a0;
            --incoming: #202c33;
            --outgoing: #005c4b;
            --shadow-card: 0 4px 18px rgba(0,0,0,0.3);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            height: 100dvh; 
            background-color: var(--bg-main); 
            color: var(--text-main); 
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        button { 
            border: none; 
            outline: none; 
            cursor: pointer; 
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
            font-family: inherit;
            user-select: none;
        }
        input, textarea { font-family: inherit; outline: none; border: none; }
        
        .app-wrapper { 
            display: flex; 
            width: 100%; 
            height: 100%; 
            max-width: 1600px; 
            margin: 0 auto; 
            position: relative; 
            background: var(--bg-panel); 
            overflow: hidden;
            isolation: isolate;
        }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .center { align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        .scroll-y { 
            overflow-y: auto; 
            scrollbar-width: thin;
            scrollbar-color: var(--text-sub) transparent;
        }
        .scroll-y::-webkit-scrollbar { width: 6px; }
        .scroll-y::-webkit-scrollbar-track { background: transparent; }
        .scroll-y::-webkit-scrollbar-thumb { background: var(--text-sub); border-radius: 3px; }

        #auth-view { 
            position: absolute; 
            inset: 0; 
            z-index: 2000; 
            background: var(--bg-main); 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        .auth-card { 
            background: var(--bg-panel); 
            width: 100%; 
            max-width: 450px; 
            padding: 40px; 
            border-radius: var(--border-radius); 
            box-shadow: var(--shadow-card); 
            text-align: center;
            animation: slideUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .auth-logo { 
            width: 80px; 
            height: 80px; 
            background: var(--primary); 
            color: white; 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 32px; 
            margin: 0 auto 20px;
            box-shadow: 0 4px 12px rgba(0, 168, 132, 0.3);
        }
        .auth-input { 
            width: 100%; 
            padding: 15px; 
            margin-bottom: 15px; 
            border: 1px solid var(--text-sub); 
            border-radius: 8px; 
            font-size: 16px; 
            background: var(--bg-panel); 
            color: var(--text-main);
            transition: border-color 0.2s;
        }
        .auth-input:focus { border-color: var(--primary); }
        .btn-primary { 
            width: 100%; 
            padding: 15px; 
            background: var(--primary); 
            color: white; 
            border-radius: 8px; 
            font-weight: 600; 
            font-size: 16px; 
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
        .btn-primary::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.1);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .btn-primary:hover::before { opacity: 1; }
        .btn-primary:active { transform: scale(0.98); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; }
        .auth-switch { margin-top: 20px; color: var(--primary); cursor: pointer; font-size: 14px; font-weight: 500; }

        aside { 
            width: var(--sidebar-width); 
            border-right: 1px solid rgba(0,0,0,0.1); 
            display: flex; 
            flex-direction: column; 
            background: var(--bg-panel); 
            z-index: 10; 
            height: 100%;
        }
        .header { 
            height: var(--header-height); 
            padding: 0 16px; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            background: var(--bg-panel); 
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        .avatar { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            background: var(--text-sub); 
            color: white; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            font-size: 18px; 
            object-fit: cover;
            user-select: none;
        }
        
        .search-container { padding: 10px; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .search-box { 
            background: rgba(0,0,0,0.05); 
            border-radius: 8px; 
            display: flex; 
            align-items: center; 
            padding: 0 10px;
            transition: background 0.2s;
        }
        .search-box:focus-within { background: rgba(0,0,0,0.08); }
        .search-box input { 
            border: none; 
            background: transparent; 
            padding: 10px; 
            flex: 1; 
            color: var(--text-main);
        }
        
        .contact-list { flex: 1; overflow-y: auto; }
        .contact-item { 
            display: flex; 
            align-items: center; 
            padding: 12px 16px; 
            cursor: pointer; 
            transition: background 0.2s; 
            position: relative;
            user-select: none;
        }
        .contact-item:hover { background: rgba(0,0,0,0.03); }
        .contact-item.active { background: rgba(0,0,0,0.06); }
        .contact-info { margin-left: 15px; flex: 1; overflow: hidden; }
        .contact-name { font-weight: 500; font-size: 17px; margin-bottom: 2px; }
        .contact-status { font-size: 13px; color: var(--text-sub); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .unread-badge { 
            background: var(--success); 
            color: white; 
            font-size: 12px; 
            padding: 2px 6px; 
            border-radius: 10px; 
            margin-left: auto;
            font-weight: bold;
        }

        main { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            background: var(--bg-chat); 
            position: relative; 
            height: 100%;
        }
        main::before { 
            content: ""; 
            position: absolute; 
            inset: 0; 
            opacity: 0.4; 
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%239ca3af' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E"); 
            pointer-events: none; 
        }

        .chat-header { 
            background: var(--bg-panel); 
            height: var(--header-height); 
            padding: 0 16px; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            border-bottom: 1px solid rgba(0,0,0,0.05); 
            z-index: 5;
        }
        .chat-back-btn { display: none; margin-right: 15px; font-size: 20px; color: var(--text-main); }
        .chat-user-meta { display: flex; align-items: center; cursor: pointer; }
        .chat-actions i { 
            font-size: 20px; 
            color: var(--primary); 
            margin-left: 25px; 
            cursor: pointer; 
            padding: 8px; 
            border-radius: 50%;
            transition: background 0.2s;
        }
        .chat-actions i:hover { background: rgba(0,0,0,0.05); }

        .messages-container { 
            flex: 1; 
            padding: 20px; 
            overflow-y: auto; 
            display: flex; 
            flex-direction: column; 
            gap: 4px; 
            z-index: 2;
            scroll-behavior: smooth;
        }
        
        .msg { 
            max-width: 65%; 
            padding: 8px 12px; 
            border-radius: 8px; 
            font-size: 15px; 
            line-height: 1.4; 
            position: relative; 
            word-wrap: break-word; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .msg-in { align-self: flex-start; background: var(--incoming); border-top-left-radius: 0; }
        .msg-out { align-self: flex-end; background: var(--outgoing); border-top-right-radius: 0; }
        .msg-time { 
            font-size: 10px; 
            color: var(--text-sub); 
            text-align: right; 
            margin-top: 4px; 
            display: block; 
            float: right; 
            margin-left: 10px;
        }
        .msg-img { 
            max-width: 100%; 
            border-radius: 6px; 
            margin-bottom: 4px; 
            display: block; 
            cursor: pointer;
            transition: transform 0.2s;
        }
        .msg-img:hover { transform: scale(1.02); }

        .input-area { 
            background: var(--bg-panel); 
            padding: 10px 16px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            z-index: 5;
        }
        .input-field { 
            flex: 1; 
            background: rgba(0,0,0,0.05); 
            border-radius: 8px; 
            padding: 12px; 
            max-height: 100px; 
            overflow-y: auto; 
            color: var(--text-main);
            font-size: 15px;
        }
        .btn-icon { 
            color: var(--text-sub); 
            font-size: 22px; 
            padding: 8px; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s, color 0.2s;
        }
        .btn-icon:hover { background: rgba(0,0,0,0.05); color: var(--primary); }
        .btn-send { color: var(--primary); }

        #call-overlay { 
            position: fixed; 
            inset: 0; 
            background: #000; 
            z-index: 3000; 
            display: flex; 
            flex-direction: column; 
            opacity: 0; 
            pointer-events: none; 
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #call-overlay.active { opacity: 1; pointer-events: auto; }
        
        .video-grid { 
            flex: 1; 
            position: relative; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow: hidden;
        }
        video { background: #000; }
        #remote-video { width: 100%; height: 100%; object-fit: contain; }
        #local-video { 
            position: absolute; 
            bottom: 100px; 
            right: 20px; 
            width: 120px; 
            height: 160px; 
            border-radius: var(--border-radius); 
            border: 2px solid white; 
            object-fit: cover; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.5); 
            z-index: 3002; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #local-video.dragging { transition: none; }
        
        .call-controls { 
            position: absolute; 
            bottom: 30px; 
            left: 0; 
            right: 0; 
            display: flex; 
            justify-content: center; 
            gap: 20px; 
            z-index: 3003; 
            padding-bottom: env(safe-area-inset-bottom);
        }
        .ctrl-btn { 
            width: 60px; 
            height: 60px; 
            border-radius: 50%; 
            background: rgba(255,255,255,0.2); 
            backdrop-filter: blur(10px); 
            color: white; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 24px; 
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        .ctrl-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.1);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .ctrl-btn:hover::before { opacity: 1; }
        .ctrl-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.1); }
        .ctrl-btn.bg-red { background: var(--danger); }
        .ctrl-btn.active { background: white; color: #333; }

        .call-status-pill { 
            position: absolute; 
            top: 40px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: rgba(0,0,0,0.6); 
            padding: 8px 20px; 
            border-radius: 30px; 
            color: white; 
            font-size: 14px; 
            z-index: 3003; 
            backdrop-filter: blur(5px);
            font-weight: 500;
        }
        .call-duration { 
            position: absolute; 
            top: 80px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: rgba(0,0,0,0.6); 
            padding: 6px 16px; 
            border-radius: 30px; 
            color: white; 
            font-size: 12px; 
            z-index: 3003; 
            backdrop-filter: blur(5px);
            font-family: monospace;
        }

        #incoming-modal { 
            position: fixed; 
            top: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(-150%); 
            background: rgba(32, 44, 51, 0.95); 
            width: 90%; 
            max-width: 400px; 
            padding: 20px; 
            border-radius: var(--border-radius); 
            z-index: 4000; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            color: white; 
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            backdrop-filter: blur(10px);
        }
        #incoming-modal.show { transform: translateX(-50%) translateY(0); }
        .incoming-info { display: flex; align-items: center; gap: 15px; }
        .incoming-actions { display: flex; gap: 15px; }
        .btn-accept { 
            background: var(--success); 
            width: 45px; 
            height: 45px; 
            border-radius: 50%; 
            color: white; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 18px; 
            animation: pulse 1.5s infinite;
            position: relative;
            overflow: hidden;
        }
        .btn-decline { 
            background: var(--danger); 
            width: 45px; 
            height: 45px; 
            border-radius: 50%; 
            color: white; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 18px;
            position: relative;
            overflow: hidden;
        }
        .btn-accept::before, .btn-decline::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.2);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .btn-accept:hover::before, .btn-decline:hover::before { opacity: 1; }

        @keyframes pulse { 
            0% { box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.7); } 
            70% { box-shadow: 0 0 0 12px rgba(37, 211, 102, 0); } 
            100% { box-shadow: 0 0 0 0 rgba(37, 211, 102, 0); } 
        }

        @media (max-width: 768px) {
            .app-wrapper { border-radius: 0; box-shadow: none; }
            aside { width: 100%; position: absolute; }
            main { width: 100%; position: absolute; transform: translateX(100%); transition: transform 0.3s ease-in-out; z-index: 20; }
            
            body.chat-open aside { transform: translateX(-20%); opacity: 0; }
            body.chat-open main { transform: translateX(0); }
            
            .chat-back-btn { display: block; }
            
            #local-video { width: 90px; height: 130px; bottom: 120px; right: 15px; }
            .msg { font-size: 16px; }
            .ctrl-btn { width: 55px; height: 55px; font-size: 20px; }
        }

        #toast-container { 
            position: fixed; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%); 
            z-index: 5000; 
            text-align: center; 
            width: 100%; 
            pointer-events: none;
        }
        .toast { 
            display: inline-block; 
            background: #333; 
            color: white; 
            padding: 12px 24px; 
            border-radius: 30px; 
            margin-top: 10px; 
            opacity: 0; 
            transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            transform: translateY(20px); 
            font-size: 14px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            font-weight: 500;
            max-width: 90%;
            word-wrap: break-word;
        }
        .toast.visible { opacity: 1; transform: translateY(0); }

        .loading-spinner { 
            border: 2px solid var(--text-sub); 
            border-top: 2px solid var(--primary); 
            border-radius: 50%; 
            width: 20px; 
            height: 20px; 
            animation: spin 1s linear infinite; 
            display: inline-block; 
            vertical-align: middle; 
            margin-left: 10px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #debug-info { 
            position: fixed; 
            top: 10px; 
            right: 10px; 
            background: rgba(0,0,0,0.9); 
            color: #0f0; 
            padding: 10px; 
            border-radius: 5px; 
            font-family: monospace; 
            font-size: 11px; 
            z-index: 9999; 
            max-width: 350px; 
            max-height: 200px; 
            overflow-y: auto; 
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        #debug-info.show { display: block; }

        .connection-quality {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            z-index: 3003;
        }
        .quality-bar {
            width: 4px;
            height: 12px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            transition: background 0.3s, height 0.3s;
        }
        .quality-bar.active { background: var(--success); }
        .quality-bar.medium { background: var(--warning); }
        .quality-bar.low { background: var(--danger); }

        .p2p-transfer {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 16px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            z-index: 3500;
            display: none;
            backdrop-filter: blur(5px);
        }
        .p2p-transfer.show { display: block; }
    </style>
</head>
<body>

    <div id="debug-info"></div>

    <div id="p2p-transfer" class="p2p-transfer">
        <i class="fas fa-exchange-alt"></i> <span id="transfer-status">P2P Transfer</span>
    </div>

    <div id="auth-view">
        <div class="auth-card">
            <div class="auth-logo"><i class="fas fa-users"></i></div>
            <h2 style="margin-bottom: 10px;">FamilyChat Pro</h2>
            <p style="color: var(--text-sub); margin-bottom: 25px;">Secure P2P Communication</p>
            
            <div id="auth-error" style="color: var(--danger); font-size: 14px; margin-bottom: 15px; display: none;"></div>
            
            <input type="text" id="auth-nick" class="auth-input" placeholder="Your Nickname (e.g. Mom)" autocomplete="off" maxlength="20">
            <input type="password" id="auth-pass" class="auth-input" placeholder="Password (min 6 chars)" autocomplete="new-password" minlength="6">
            
            <button id="btn-auth-action" class="btn-primary" onclick="App.auth.login()">
                <span id="auth-btn-text">Login</span>
                <span id="auth-loading" class="loading-spinner hidden"></span>
            </button>
            
            <div class="auth-switch" onclick="App.auth.toggleMode()">
                <span id="auth-switch-text">New here? Create Account</span>
            </div>
            
            <div style="margin-top: 20px; font-size: 12px; color: var(--text-sub);">
                <i class="fas fa-shield-alt"></i> End-to-end encrypted calls<br>
                <button type="button" onclick="App.ui.toggleDebug()" style="background: none; border: none; color: var(--primary); cursor: pointer; font-size: 12px;">
                    <i class="fas fa-bug"></i> Debug Mode
                </button>
            </div>
        </div>
    </div>

    <div id="app-view" class="app-wrapper hidden">
        
        <aside>
            <div class="header">
                <div class="flex center" style="gap: 12px; cursor: pointer;" onclick="App.ui.showProfileSettings()">
                    <div id="my-avatar" class="avatar"></div>
                    <div style="font-weight: 600;" id="my-nick"></div>
                </div>
                <div class="flex" style="gap: 15px;">
                    <button class="btn-icon" onclick="App.ui.toggleTheme()" title="Toggle theme"><i class="fas fa-adjust"></i></button>
                    <button class="btn-icon" onclick="App.auth.logout()" title="Logout"><i class="fas fa-sign-out-alt"></i></button>
                </div>
            </div>
            
            <div class="search-container">
                <div class="search-box">
                    <i class="fas fa-search" style="color: var(--text-sub);"></i>
                    <input type="text" id="contact-search" placeholder="Search or add by nickname..." onkeyup="App.chat.handleSearchKey(event)">
                    <button onclick="App.contacts.searchUser()" style="padding: 8px; color: var(--primary); font-weight: bold;">ADD</button>
                </div>
            </div>

            <div id="contacts-list" class="contact-list scroll-y">
                <div class="center flex flex-col" style="height: 100%; color: var(--text-sub); opacity: 0.6;">
                    <i class="fas fa-search" style="font-size: 32px; margin-bottom: 10px;"></i>
                    <p>Search for family members to add them!</p>
                </div>
            </div>
        </aside>

        <main>
            <div class="chat-header">
                <div class="flex center">
                    <button class="chat-back-btn" onclick="App.ui.closeChat()"><i class="fas fa-arrow-left"></i></button>
                    <div class="chat-user-meta">
                        <div id="chat-avatar" class="avatar" style="width: 36px; height: 36px; margin-right: 10px; font-size: 14px;"></div>
                        <div>
                            <div id="chat-name" style="font-weight: 600; font-size: 16px;"></div>
                            <div id="chat-status" style="font-size: 12px; color: var(--text-sub);">Offline</div>
                        </div>
                    </div>
                </div>
                <div class="chat-actions flex">
                    <i class="fas fa-video" onclick="App.call.startCall()" title="Start video call"></i>
                    <i class="fas fa-phone" onclick="App.call.startCall(true)" title="Start voice call"></i>
                </div>
            </div>

            <div id="messages-area" class="messages-container">
                <div class="center flex flex-col" style="height: 100%; color: var(--text-sub); opacity: 0.6;">
                    <i class="fas fa-comments" style="font-size: 48px; margin-bottom: 20px;"></i>
                    <p>Select a contact to start chatting</p>
                </div>
            </div>

            <div id="input-area" class="input-area hidden">
                <button class="btn-icon" onclick="document.getElementById('file-upload').click()" title="Attach file"><i class="fas fa-paperclip"></i></button>
                <input type="file" id="file-upload" hidden onchange="App.chat.handleFileUpload(this)">
                
                <input type="text" id="msg-input" class="input-field" placeholder="Type a message..." onkeydown="App.chat.handleMessageKey(event)">
                
                <button class="btn-icon btn-send" onclick="App.chat.sendMessage()" title="Send message"><i class="fas fa-paper-plane"></i></button>
            </div>
        </main>
    </div>

    <div id="incoming-modal">
        <div class="incoming-info">
            <div id="caller-avatar" class="avatar" style="background: white; color: #333;">?</div>
            <div>
                <div style="font-size: 12px; opacity: 0.8;">Incoming <span id="call-type">Video</span> Call</div>
                <div id="caller-name" style="font-weight: bold; font-size: 18px;">Unknown</div>
            </div>
        </div>
        <div class="incoming-actions">
            <button class="btn-decline" onclick="App.call.rejectCall()"><i class="fas fa-times"></i></button>
            <button class="btn-accept" onclick="App.call.acceptCall()"><i class="fas fa-video"></i></button>
        </div>
    </div>

    <div id="call-overlay">
        <div class="call-status-pill" id="call-status-text">Initializing...</div>
        <div class="call-duration" id="call-duration">00:00</div>
        
        <div class="connection-quality" id="connection-quality" style="display: none;">
            <div class="quality-bar"></div>
            <div class="quality-bar"></div>
            <div class="quality-bar"></div>
            <div class="quality-bar"></div>
        </div>
        
        <div class="video-grid">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
        </div>

        <div class="call-controls">
            <button class="ctrl-btn" onclick="App.call.toggleAudio()" id="btn-mute" title="Toggle microphone"><i class="fas fa-microphone"></i></button>
            <button class="ctrl-btn" onclick="App.call.toggleScreenShare()" id="btn-screen" title="Share screen"><i class="fas fa-desktop"></i></button>
            <button class="ctrl-btn bg-red" onclick="App.call.endCall()" title="End call"><i class="fas fa-phone-slash"></i></button>
            <button class="ctrl-btn" onclick="App.call.toggleVideo()" id="btn-cam" title="Toggle camera"><i class="fas fa-video"></i></button>
            <button class="ctrl-btn" onclick="App.call.flipCamera()" id="btn-flip" title="Flip camera"><i class="fas fa-camera-rotate"></i></button>
        </div>
    </div>

    <div id="toast-container"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, onSnapshot, orderBy, serverTimestamp, doc, setDoc, getDoc, updateDoc, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";


const firebaseConfig = {
  apiKey: "AIzaSyDXsvsaG8IdcjZv4iG4WHjPneGvcxywuTk",
  authDomain: "bobba-591c5.firebaseapp.com",
  projectId: "bobba-591c5",
  storageBucket: "bobba-591c5.firebasestorage.app",
  messagingSenderId: "839501020120",
  appId: "1:839501020120:web:0e58d4759785a1fadfd0ad",
  measurementId: "G-C3D5TB22F0"
};

        window.debugLog = function(message, type = 'info') {
            const panel = document.getElementById('debug-info');
            if (!panel?.classList.contains('show')) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const colors = { info: '#0f0', warn: '#ff0', error: '#f00', success: '#0f0' };
            panel.innerHTML += `<div style="color:${colors[type]}">[${timestamp}] ${message}</div>`;
            panel.scrollTop = panel.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        };

        let app, auth, db, storage;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            storage = getStorage(app);
            debugLog("‚úÖ Firebase initialized");
        } catch(e) {
            debugLog(`‚ùå Firebase init failed: ${e.message}`, 'error');
            alert("Critical Error: Firebase initialization failed. Check console.");
            throw e;
        }

        const CallState = {
            IDLE: 'idle',
            CONNECTING: 'connecting',
            RECEIVING: 'receiving',
            CONNECTED: 'connected',
            ENDED: 'ended'
        };

        const State = {
            user: null,
            activeContact: null,
            contactsMap: new Map(),
            peer: null,
            currentCall: null,
            tempCall: null,
            dataConnection: null,
            localStream: null,
            screenStream: null,
            unsubscribeChat: null,
            callState: CallState.IDLE,
            callStartTime: null,
            callDurationInterval: null,
            reconnectionAttempts: 0,
            maxReconnectionAttempts: 5,
            callTimeout: null,
            isMuted: false,
            isVideoOff: false,
            isScreenSharing: false,
            incomingFile: null,
            statsInterval: null,
            callStats: {
                startTime: null,
                iceCandidates: 0,
                connectionAttempts: 0,
                bytesSent: 0,
                bytesReceived: 0,
                packetsLost: 0
            }
        };

        class UIManager {
            constructor() {
                this.initializeDOM();
                this.initTheme();
                this.setupEventListeners();
            }

            initializeDOM() {
                this.dom = {
                    auth: document.getElementById('auth-view'),
                    app: document.getElementById('app-view'),
                    msgArea: document.getElementById('messages-area'),
                    inputArea: document.getElementById('input-area'),
                    contactList: document.getElementById('contacts-list'),
                    authLoading: document.getElementById('auth-loading'),
                    authBtnText: document.getElementById('auth-btn-text'),
                    callDuration: document.getElementById('call-duration'),
                    callStatus: document.getElementById('call-status-text'),
                    connectionQuality: document.getElementById('connection-quality'),
                    incomingModal: document.getElementById('incoming-modal'),
                    callOverlay: document.getElementById('call-overlay')
                };
            }

            setupEventListeners() {
                window.addEventListener('resize', this.handleResize.bind(this));
                document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
            }

            handleResize() {
                if (window.innerWidth < 400) {
                    const localVideo = document.getElementById('local-video');
                    if (localVideo) {
                        localVideo.style.width = '80px';
                        localVideo.style.height = '110px';
                    }
                }
            }

            handleVisibilityChange() {
                if (document.hidden && State.localStream) {
                    State.localStream.getVideoTracks().forEach(track => track.enabled = false);
                } else if (State.localStream && !State.isVideoOff) {
                    State.localStream.getVideoTracks().forEach(track => track.enabled = true);
                }
            }

            toast(msg, type = 'info', duration = 4000) {
                const container = document.getElementById('toast-container');
                const el = document.createElement('div');
                el.className = 'toast';
                el.textContent = msg;
                
                const colors = {
                    error: 'var(--danger)',
                    success: 'var(--success)',
                    warning: 'var(--warning)'
                };
                if (colors[type]) el.style.background = colors[type];
                
                container.appendChild(el);
                requestAnimationFrame(() => el.classList.add('visible'));
                
                setTimeout(() => {
                    el.classList.remove('visible');
                    setTimeout(() => el.remove(), 300);
                }, duration);
            }

            setLoading(isLoading, element = null) {
                document.body.style.cursor = isLoading ? 'wait' : 'default';
                if (element) element.disabled = isLoading;
                if (this.dom.authLoading) {
                    this.dom.authLoading.classList.toggle('hidden', !isLoading);
                }
            }

            toggleTheme() {
                const body = document.body;
                const current = body.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                body.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                this.toast(`Theme: ${next}`, 'success');
            }

            initTheme() {
                const saved = localStorage.getItem('theme') || 'light';
                document.body.setAttribute('data-theme', saved);
            }

            showApp() {
                this.dom.auth.classList.add('hidden');
                this.dom.app.classList.remove('hidden');
                document.getElementById('my-nick').textContent = State.user.nickname;
                document.getElementById('my-avatar').textContent = State.user.nickname[0].toUpperCase();
            }

            showAuth() {
                this.dom.app.classList.add('hidden');
                this.dom.auth.classList.remove('hidden');
            }

            openChatUI(contact) {
                document.body.classList.add('chat-open');
                document.getElementById('chat-name').textContent = contact.nickname;
                document.getElementById('chat-avatar').textContent = contact.nickname[0].toUpperCase();
                this.dom.inputArea.classList.remove('hidden');
                this.dom.msgArea.innerHTML = '';
            }

            closeChat() {
                document.body.classList.remove('chat-open');
                State.activeContact = null;
                if (State.unsubscribeChat) {
                    State.unsubscribeChat();
                    State.unsubscribeChat = null;
                }
            }

            showProfileSettings() {
                this.toast("Profile settings coming soon!");
            }

            toggleDebug() {
                const panel = document.getElementById('debug-info');
                panel.classList.toggle('show');
                debugLog("Debug panel toggled");
            }

            showCallError(message) {
                this.toast(`Call Error: ${message}`, 'error');
                debugLog(`‚ùå Call error: ${message}`, 'error');
            }

            updateCallDuration() {
                if (!State.callStartTime) return;
                const elapsed = Math.floor((Date.now() - State.callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const durationText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                this.dom.callDuration.textContent = durationText;
            }

            showCallDuration(visible) {
                this.dom.callDuration.style.display = visible ? 'block' : 'none';
                if (visible && !State.callDurationInterval) {
                    State.callDurationInterval = setInterval(() => this.updateCallDuration(), 1000);
                } else if (!visible && State.callDurationInterval) {
                    clearInterval(State.callDurationInterval);
                    State.callDurationInterval = null;
                    this.dom.callDuration.textContent = '00:00';
                }
            }

            updateConnectionQuality(stats) {
                if (!stats) return;
                
                const quality = this.calculateQuality(stats);
                const bars = this.dom.connectionQuality.querySelectorAll('.quality-bar');
                
                bars.forEach((bar, index) => {
                    bar.classList.remove('active', 'medium', 'low');
                    if (index < quality.bars) {
                        bar.classList.add('active', quality.level);
                    }
                });
                
                this.dom.connectionQuality.style.display = 'flex';
            }

            calculateQuality(stats) {
                const { packetsLost, packetsReceived, jitter, rtt } = stats;
                if (!packetsReceived || packetsReceived === 0) return { bars: 0, level: 'low' };
                
                const lossRate = (packetsLost / packetsReceived) * 100;
                
                if (lossRate < 1 && jitter < 30 && rtt < 100) {
                    return { bars: 4, level: 'active' };
                } else if (lossRate < 3 && jitter < 50 && rtt < 200) {
                    return { bars: 3, level: 'active' };
                } else if (lossRate < 5 && jitter < 100 && rtt < 300) {
                    return { bars: 2, level: 'medium' };
                } else {
                    return { bars: 1, level: 'low' };
                }
            }

            showP2PTransfer(show = true, status = 'Transferring...') {
                const indicator = document.getElementById('p2p-transfer');
                const statusEl = document.getElementById('transfer-status');
                statusEl.textContent = status;
                indicator.classList.toggle('show', show);
            }

            // OPEN CALL OVERLAY FOR BOTH CALLER AND CALLEE
            openCallOverlay() {
                this.dom.callOverlay.classList.add('active');
                this.dom.callStatus.style.display = 'block';
                this.dom.callStatus.innerText = 'Connecting...';
            }

            closeCallOverlay() {
                this.dom.callOverlay.classList.remove('active');
                this.dom.callStatus.style.display = 'none';
                this.dom.connectionQuality.style.display = 'none';
            }
        }

        class AuthService {
            constructor() {
                this.isRegistering = false;
                this.rateLimit = {
                    lastAttempt: 0,
                    minInterval: 1000
                };
            }

            toggleMode() {
                this.isRegistering = !this.isRegistering;
                const btnText = this.isRegistering ? 'Create Account' : 'Login';
                const switchText = this.isRegistering ? 'Have an account? Login' : 'New here? Create Account';
                
                document.getElementById('auth-btn-text').textContent = btnText;
                document.getElementById('auth-switch-text').textContent = switchText;
                document.getElementById('auth-error').style.display = 'none';
            }

            checkRateLimit() {
                const now = Date.now();
                if (now - this.rateLimit.lastAttempt < this.rateLimit.minInterval) {
                    App.ui.toast("Please wait before trying again", 'warning');
                    return false;
                }
                this.rateLimit.lastAttempt = now;
                return true;
            }

            async login() {
                if (!this.checkRateLimit()) return;

                const nick = document.getElementById('auth-nick').value.trim();
                const pass = document.getElementById('auth-pass').value;

                if (!nick || !pass) {
                    this.showError("All fields are required");
                    return;
                }
                
                if (nick.length < 3 || nick.length > 20) {
                    this.showError("Nickname must be 3-20 characters");
                    return;
                }
                
                if (pass.length < 6) {
                    this.showError("Password must be at least 6 characters");
                    return;
                }

                const sanitizedNick = this.sanitizeInput(nick);
                const email = this.generateEmail(sanitizedNick);
                debugLog(`üìß Generated email: ${email}`);

                try {
                    App.ui.setLoading(true, document.getElementById('btn-auth-action'));
                    document.getElementById('auth-error').style.display = 'none';

                    if (this.isRegistering) {
                        await this.registerUser(sanitizedNick, email, pass);
                    } else {
                        await this.signInUser(email, pass);
                    }
                    debugLog("‚úÖ Authentication successful");
                } catch (e) {
                    debugLog(`‚ùå Auth error: ${e.code}`, 'error');
                    this.handleAuthError(e);
                } finally {
                    App.ui.setLoading(false);
                }
            }

            sanitizeInput(input) {
                return input.replace(/[<>\"'&]/g, '');
            }

            async registerUser(nickname, email, password) {
                debugLog("üîç Checking nickname availability...");
                const q = query(collection(db, "users"), where("nickname", "==", nickname));
                const check = await getDocs(q);
                
                if (!check.empty) {
                    throw new Error("Nickname already taken!");
                }

                debugLog("üë§ Creating new user...");
                const cred = await createUserWithEmailAndPassword(auth, email, password);
                
                debugLog("üìù Creating user document...");
                await setDoc(doc(db, "users", cred.user.uid), {
                    uid: cred.user.uid,
                    nickname: nickname,
                    email: email,
                    contacts: [],
                    peerId: this.generatePeerId(nickname, cred.user.uid),
                    createdAt: serverTimestamp(),
                    lastSeen: serverTimestamp()
                });
                
                await updateProfile(cred.user, { displayName: nickname });
            }

            async signInUser(email, password) {
                debugLog("üîê Signing in existing user...");
                await signInWithEmailAndPassword(auth, email, password);
                
                const userDoc = doc(db, "users", auth.currentUser.uid);
                await updateDoc(userDoc, { lastSeen: serverTimestamp() });
            }

            generateEmail(nickname) {
                const sanitized = nickname.toLowerCase().replace(/[^a-z0-9]/g, '');
                return `${sanitized}@familychat.app`;
            }

            generatePeerId(nickname, uid) {
                const sanitized = nickname.replace(/[^a-zA-Z0-9]/g, '');
                return `${sanitized}_${uid.substring(0, 8)}`;
            }

            handleAuthError(error) {
                const errorMap = {
                    'auth/network-request-failed': "Network error. Please check your connection",
                    'auth/invalid-email': "Invalid email format",
                    'auth/user-not-found': "Account not found",
                    'auth/wrong-password': "Incorrect password",
                    'auth/email-already-in-use': "Nickname already taken",
                    'auth/too-many-requests': "Too many attempts. Please try later",
                    'auth/operation-not-allowed': "Email authentication not enabled",
                    'auth/api-key-not-valid': "Invalid API key configuration"
                };
                
                const msg = errorMap[error.code] || error.message.substring(0, 60);
                this.showError(msg);
            }

            showError(message) {
                const errDiv = document.getElementById('auth-error');
                errDiv.style.display = 'block';
                errDiv.textContent = message;
            }

            async logout() {
                if (State.callState !== CallState.IDLE) {
                    debugLog("üìû Ending call before logout");
                    App.call.endCall();
                }
                
                debugLog("üö™ Logging out user...");
                try {
                    await signOut(auth);
                    window.location.reload();
                } catch (e) {
                    debugLog(`‚ùå Logout error: ${e.message}`, 'error');
                    App.ui.toast("Logout failed", 'error');
                }
            }
        }

        class ChatService {
            constructor() {
                this.searchDebounceTimer = null;
                this.fileUploadQueue = [];
                this.init();
            }

            init() {
                this.initVideoDrag();
            }

            initVideoDrag() {
                let isDragging = false, currentX = 0, currentY = 0, initialX = 0, initialY = 0, xOffset = 0, yOffset = 0;
                const video = document.getElementById('local-video');

                const dragStart = (e) => {
                    if (e.target !== video) return;
                    isDragging = true;
                    video.classList.add('dragging');
                    
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    initialX = clientX - xOffset;
                    initialY = clientY - yOffset;
                };

                const dragEnd = () => {
                    isDragging = false;
                    video.classList.remove('dragging');
                    initialX = currentX;
                    initialY = currentY;
                };

                const drag = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    currentX = clientX - initialX;
                    currentY = clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    
                    video.style.transform = `translate(${currentX}px, ${currentY}px)`;
                };

                video.addEventListener('mousedown', dragStart);
                video.addEventListener('mouseup', dragEnd);
                video.addEventListener('mousemove', drag);
                
                video.addEventListener('touchstart', dragStart, { passive: false });
                video.addEventListener('touchend', dragEnd);
                video.addEventListener('touchmove', drag, { passive: false });
            }

            async loadContacts() {
                if (!State.user?.contacts?.length) {
                    this.renderEmptyContactList();
                    return;
                }
                
                const list = document.getElementById('contacts-list');
                list.innerHTML = '';

                const chunks = [];
                for (let i = 0; i < State.user.contacts.length; i += 10) {
                    chunks.push(State.user.contacts.slice(i, i + 10));
                }

                try {
                    for (const chunk of chunks) {
                        const q = query(collection(db, "users"), where("uid", "in", chunk));
                        const snap = await getDocs(q);
                        snap.forEach(d => {
                            const contact = d.data();
                            State.contactsMap.set(contact.uid, contact);
                            this.renderContactItem(contact);
                        });
                    }
                    debugLog(`‚úÖ Loaded ${State.contactsMap.size} contacts`);
                } catch (e) {
                    debugLog(`‚ùå Load contacts error: ${e.message}`, 'error');
                    App.ui.toast("Error loading contacts", 'error');
                }
            }

            renderEmptyContactList() {
                const list = document.getElementById('contacts-list');
                list.innerHTML = `
                    <div class="center flex flex-col" style="height: 100%; color: var(--text-sub); opacity: 0.6; padding: 40px;">
                        <i class="fas fa-search" style="font-size: 32px; margin-bottom: 10px;"></i>
                        <p>Search for family members to add them!</p>
                    </div>
                `;
            }

            renderContactItem(contact) {
                const list = document.getElementById('contacts-list');
                const div = document.createElement('div');
                div.className = 'contact-item';
                div.dataset.uid = contact.uid;
                div.innerHTML = `
                    <div class="avatar">${contact.nickname[0].toUpperCase()}</div>
                    <div class="contact-info">
                        <div class="contact-name">${this.escapeHtml(contact.nickname)}</div>
                        <div class="contact-status">Tap to chat</div>
                    </div>
                `;
                div.onclick = () => this.startChat(contact);
                list.appendChild(div);
            }

            handleSearchKey(event) {
                if (event.key === 'Enter') {
                    this.searchUser();
                    return;
                }
                
                if (this.searchDebounceTimer) {
                    clearTimeout(this.searchDebounceTimer);
                }
                
                this.searchDebounceTimer = setTimeout(() => {
                    const input = event.target;
                    if (input.value.trim().length >= 3) {
                        this.searchUser();
                    }
                }, 300);
            }

            async searchUser() {
                const input = document.getElementById('contact-search');
                const val = input.value.trim();
                
                if (!val) {
                    App.ui.toast("Enter a nickname to search", 'warning');
                    return;
                }
                
                if (val.length < 3) {
                    App.ui.toast("Search query must be at least 3 characters", 'warning');
                    return;
                }
                
                if (val === State.user.nickname) {
                    App.ui.toast("That's you!", 'warning');
                    return;
                }

                App.ui.setLoading(true);
                debugLog(`üîç Searching for: ${val}`);
                
                try {
                    const q = query(
                        collection(db, "users"), 
                        where("nickname", ">=", val),
                        where("nickname", "<=", val + '\uf8ff')
                    );
                    const snap = await getDocs(q);
                    
                    if (snap.empty) {
                        App.ui.toast("User not found", 'warning');
                        debugLog("‚ùå User not found");
                    } else {
                        const newUser = snap.docs[0].data();
                        await this.addContact(newUser);
                        input.value = '';
                    }
                } catch (e) {
                    debugLog(`‚ùå Search error: ${e.message}`, 'error');
                    App.ui.toast("Search failed", 'error');
                } finally {
                    App.ui.setLoading(false);
                }
            }

            async addContact(newUser) {
                if (State.user.contacts.includes(newUser.uid)) {
                    App.ui.toast("Already in contacts", 'info');
                    return;
                }

                try {
                    const myRef = doc(db, "users", State.user.uid);
                    const updatedContacts = [...State.user.contacts, newUser.uid];
                    
                    await updateDoc(myRef, { contacts: updatedContacts });
                    State.user.contacts = updatedContacts;
                    
                    State.contactsMap.set(newUser.uid, newUser);
                    this.renderContactItem(newUser);
                    App.ui.toast("Added to contacts!", 'success');
                    debugLog(`‚úÖ Added contact: ${newUser.nickname}`);
                } catch (e) {
                    debugLog(`‚ùå Add contact error: ${e.message}`, 'error');
                    App.ui.toast("Failed to add contact", 'error');
                }
            }

            startChat(contact) {
                document.querySelectorAll('.contact-item').forEach(item => item.classList.remove('active'));
                document.querySelector(`[data-uid="${contact.uid}"]`)?.classList.add('active');

                State.activeContact = contact;
                App.ui.openChatUI(contact);
                this.loadChatMessages(contact);
            }

            loadChatMessages(contact) {
                const chatId = this.getChatId(State.user.uid, contact.uid);
                const q = query(
                    collection(db, "chats", chatId, "messages"), 
                    orderBy("createdAt", "asc")
                );

                if (State.unsubscribeChat) {
                    State.unsubscribeChat();
                    State.unsubscribeChat = null;
                }

                State.unsubscribeChat = onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            this.renderMessage(change.doc.data());
                        }
                    });
                }, (error) => {
                    debugLog(`‚ùå Chat listener error: ${error.message}`, 'error');
                    App.ui.toast("Error loading messages", 'error');
                });
            }

            getChatId(uid1, uid2) {
                return [uid1, uid2].sort().join("_");
            }

            renderMessage(msg) {
                const isMe = msg.senderId === State.user.uid;
                const div = document.createElement('div');
                div.className = `msg ${isMe ? 'msg-out' : 'msg-in'}`;
                
                let content = `<span>${this.escapeHtml(msg.text || '')}</span>`;
                
                if (msg.type === 'image' && msg.fileUrl) {
                    content = `<img src="${msg.fileUrl}" class="msg-img" onclick="window.open('${msg.fileUrl}', '_blank')" alt="Image" loading="lazy">` + content;
                } else if (msg.type === 'file' && msg.fileUrl) {
                    content = `<a href="${msg.fileUrl}" target="_blank" style="color:var(--primary); text-decoration:none; display:flex; align-items:center; gap:8px;"><i class="fas fa-file-alt"></i> ${this.escapeHtml(msg.name || 'File')}</a><br>` + content;
                } else if (msg.type === 'p2p-file' && msg.metadata) {
                    content = `<div style="color:var(--primary); display:flex; align-items:center; gap:8px;"><i class="fas fa-exchange-alt"></i> P2P File: ${this.escapeHtml(msg.metadata.name)} (${this.formatFileSize(msg.metadata.size)})</div>` + content;
                }

                const date = msg.createdAt?.toDate ? msg.createdAt.toDate() : new Date();
                const time = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

                div.innerHTML = `${content} <span class="msg-time">${time}</span>`;
                
                const area = document.getElementById('messages-area');
                area.appendChild(div);
                
                const isNearBottom = area.scrollHeight - area.scrollTop - area.clientHeight < 100;
                if (isNearBottom) {
                    area.scrollTop = area.scrollHeight;
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            handleMessageKey(event) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.sendMessage();
                }
            }

            async sendMessage(fileData = null) {
                if (!State.activeContact) {
                    debugLog("‚ùå No active contact", 'error');
                    return;
                }
                
                const input = document.getElementById('msg-input');
                const text = input.value.trim();
                
                if (!text && !fileData) {
                    debugLog("‚ùå Empty message", 'warn');
                    return;
                }

                const chatId = this.getChatId(State.user.uid, State.activeContact.uid);
                const messageData = {
                    text: fileData ? (fileData.name || text) : text,
                    senderId: State.user.uid,
                    createdAt: serverTimestamp(),
                    type: fileData ? fileData.type : 'text',
                    fileUrl: fileData ? fileData.url : null,
                    metadata: fileData ? fileData.metadata : null
                };

                try {
                    debugLog(`üì§ Sending message...`);
                    await addDoc(collection(db, "chats", chatId, "messages"), messageData);
                    if (!fileData) input.value = '';
                    debugLog("‚úÖ Message sent");
                } catch (e) {
                    debugLog(`‚ùå Send error: ${e.message}`, 'error');
                    App.ui.toast("Failed to send message", 'error');
                }
            }

            async handleFileUpload(input) {
                const file = input.files[0];
                if (!file) return;
                
                if (file.size > 50 * 1024 * 1024) {
                    App.ui.toast("File too large (max 50MB)", 'error');
                    input.value = '';
                    return;
                }

                if (State.callState === CallState.CONNECTED && State.dataConnection?.open) {
                    this.sendFileP2P(file);
                    input.value = '';
                    return;
                }

                await this.uploadToStorage(file);
                input.value = '';
            }

            sendFileP2P(file) {
                if (!State.dataConnection || !State.dataConnection.open) {
                    App.ui.toast("P2P connection not available", 'warning');
                    return;
                }

                const reader = new FileReader();
                const chunkSize = 16 * 1024;
                let offset = 0;
                const fileId = Date.now();

                reader.onload = (e) => {
                    const chunk = e.target.result;
                    const isLast = offset >= file.size;
                    
                    State.dataConnection.send({
                        type: 'file-chunk',
                        fileId,
                        chunk: isLast ? null : chunk,
                        metadata: {
                            name: file.name,
                            size: file.size,
                            type: file.type
                        },
                        offset,
                        isLast
                    });

                    if (!isLast) {
                        offset += chunkSize;
                        readNextChunk();
                        const progress = Math.min((offset / file.size) * 100, 100);
                        App.ui.showP2PTransfer(true, `Sending: ${Math.round(progress)}%`);
                    } else {
                        App.ui.showP2PTransfer(false);
                        this.sendMessage({
                            type: 'p2p-file',
                            metadata: { name: file.name, size: file.size }
                        });
                        App.ui.toast("P2P file sent!", 'success');
                    }
                };

                const readNextChunk = () => {
                    const slice = file.slice(offset, offset + chunkSize);
                    reader.readAsArrayBuffer(slice);
                };

                readNextChunk();
                debugLog(`üì§ Starting P2P file transfer: ${file.name}`);
            }

            handleIncomingFile(data) {
                if (!State.incomingFile) {
                    State.incomingFile = {
                        chunks: [],
                        metadata: data.metadata,
                        fileId: data.fileId
                    };
                }

                if (data.chunk) {
                    State.incomingFile.chunks.push(data.chunk);
                }

                if (data.isLast) {
                    const blob = new Blob(State.incomingFile.chunks, { 
                        type: State.incomingFile.metadata.type 
                    });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = State.incomingFile.metadata.name;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    App.ui.showP2PTransfer(false);
                    App.ui.toast("P2P file received!", 'success');
                    debugLog(`‚úÖ P2P file transfer complete: ${State.incomingFile.metadata.name}`);
                    
                    this.sendMessage({
                        type: 'p2p-file',
                        metadata: State.incomingFile.metadata
                    });
                    
                    State.incomingFile = null;
                } else {
                    const progress = Math.min((data.offset / data.metadata.size) * 100, 100);
                    App.ui.showP2PTransfer(true, `Receiving: ${Math.round(progress)}%`);
                }
            }

            async uploadToStorage(file) {
                App.ui.setLoading(true);
                App.ui.toast("Uploading to cloud...", 'info');
                
                try {
                    const storageRef = ref(storage, `chat/${Date.now()}_${file.name}`);
                    const uploadTask = uploadBytes(storageRef, file);
                    
                    uploadTask.on('state_changed', 
                        (snapshot) => {
                            const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                            debugLog(`üì§ Upload progress: ${progress.toFixed(1)}%`);
                        },
                        (error) => {
                            debugLog(`‚ùå Upload failed: ${error.message}`, 'error');
                            App.ui.toast("Upload failed", 'error');
                        }
                    );

                    const snap = await uploadTask;
                    const url = await getDownloadURL(snap.ref);
                    const type = file.type.startsWith('image/') ? 'image' : 'file';
                    
                    await this.sendMessage({ 
                        url, 
                        type, 
                        name: file.name,
                        metadata: { size: file.size }
                    });
                    
                    App.ui.toast("File uploaded!", 'success');
                    debugLog("‚úÖ Cloud upload complete");
                } catch(e) {
                    debugLog(`‚ùå Upload error: ${e.message}`, 'error');
                    App.ui.toast("Upload failed", 'error');
                } finally {
                    App.ui.setLoading(false);
                }
            }
        }

        class CallService {
            constructor() {
                this.audioCtx = null;
                this.oscillator = null;
                this.ringInterval = null;
                
                this.iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun.cloudflare.com:3478' },
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ];
            }

            init() {
                const safeId = this.generatePeerId(State.user.nickname, State.user.uid);
                debugLog(`üé¨ Initializing PeerJS v1.5.4: ${safeId}`);
                
                this.peer = new Peer(safeId, {
                    host: '0.peerjs.com',
                    port: 443,
                    secure: true,
                    debug: 2, // REDUCED DEBUG LEVEL to minimize errors
                    config: {
                        iceServers: this.iceServers,
                        iceCandidatePoolSize: 10,
                        iceTransportPolicy: 'all',
                        rtcpMuxPolicy: 'require',
                        tcpCandidatePolicy: 'enabled',
                        bundlePolicy: 'max-bundle',
                        iceConnectionReceivingTimeout: 90000,
                        iceGatheringTimeout: 15000
                    }
                });

                this.setupPeerEvents();
            }

            generatePeerId(nickname, uid) {
                const sanitized = nickname.replace(/[^a-zA-Z0-9]/g, '');
                return `${sanitized}_${uid.substring(0, 8)}`;
            }

            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    debugLog(`‚úÖ PeerJS connected: ${id}`);
                    App.ui.toast("‚úÖ P2P messenger ready!", 'success');
                    State.reconnectionAttempts = 0;
                    this.updateMyPeerId(id);
                });

                this.peer.on('call', (call) => {
                    debugLog(`üìû Incoming call: ${call.peer}`);
                    this.handleIncomingCall(call);
                });

                this.peer.on('connection', (connection) => {
                    debugLog(`üîó P2P data connection: ${connection.peer}`);
                    this.handleDataConnection(connection);
                });

                this.peer.on('error', (err) => {
                    // REDUCED ERROR LOGGING - only log critical errors
                    if (err.type === 'webrtc' || err.type === 'network') {
                        debugLog(`‚ùå PeerJS ${err.type}: ${err.message}`, 'error');
                    }
                    this.handlePeerError(err);
                });

                this.peer.on('disconnected', () => {
                    debugLog("‚ö†Ô∏è Peer disconnected, attempting reconnection");
                    App.ui.toast("Connection lost, reconnecting...", 'warning');
                    this.attemptReconnection();
                });
            }

            async updateMyPeerId(peerId) {
                try {
                    const userDoc = doc(db, "users", State.user.uid);
                    await updateDoc(userDoc, { peerId, lastSeen: serverTimestamp() });
                    debugLog(`üìå Updated peer ID: ${peerId}`);
                } catch (e) {
                    debugLog(`‚ùå Failed to update peer ID: ${e.message}`, 'error');
                }
            }

            handlePeerError(err) {
                const errorHandlers = {
                    'unavailable-id': () => {
                        App.ui.toast("ID conflict, reloading...", 'error');
                        setTimeout(() => location.reload(), 2000);
                    },
                    'network': () => App.ui.toast("Network error. Check connection", 'error'),
                    'server-error': () => App.ui.toast("Signaling server error", 'error'),
                    'browser-incompatible': () => App.ui.toast("Browser not supported", 'error'),
                    'webrtc': () => App.ui.toast("WebRTC error", 'error')
                };

                const handler = errorHandlers[err.type];
                if (handler) handler();
                else App.ui.toast(err.message || 'Unknown error', 'error');

                if (State.callState !== CallState.IDLE) {
                    this.endCall();
                }
            }

            attemptReconnection() {
                if (State.reconnectionAttempts >= State.maxReconnectionAttempts) {
                    App.ui.toast("Failed to reconnect", 'error');
                    debugLog("‚ùå Max reconnection attempts exceeded", 'error');
                    if (State.callState !== CallState.IDLE) this.endCall();
                    return;
                }

                State.reconnectionAttempts++;
                debugLog(`üîÑ Reconnection attempt ${State.reconnectionAttempts}/${State.maxReconnectionAttempts}`);
                
                setTimeout(() => {
                    this.peer.reconnect();
                }, 2000 * State.reconnectionAttempts);
            }

            async ensureAudioContext() {
                if (!this.audioCtx) {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioCtx.state === 'suspended') {
                    await this.audioCtx.resume();
                }
                return this.audioCtx;
            }

            async playRing(type = 'incoming') {
                try {
                    await this.ensureAudioContext();
                    this.stopRing();

                    this.oscillator = this.audioCtx.createOscillator();
                    const gainNode = this.audioCtx.createGain();

                    this.oscillator.connect(gainNode);
                    gainNode.connect(this.audioCtx.destination);

                    if (type === 'incoming') {
                        this.oscillator.type = 'sine';
                        this.oscillator.frequency.setValueAtTime(800, this.audioCtx.currentTime);
                        gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
                        
                        const now = this.audioCtx.currentTime;
                        gainNode.gain.linearRampToValueAtTime(0.25, now + 0.1);
                        gainNode.gain.linearRampToValueAtTime(0, now + 1.5);
                        
                        this.oscillator.start(now);
                        this.oscillator.stop(now + 1.5);
                        
                        this.ringInterval = setInterval(() => {
                             const osc = this.audioCtx.createOscillator();
                             const gn = this.audioCtx.createGain();
                             osc.connect(gn);
                             gn.connect(this.audioCtx.destination);
                             osc.frequency.setValueAtTime(800, this.audioCtx.currentTime);
                             gn.gain.setValueAtTime(0, this.audioCtx.currentTime);
                             gn.gain.linearRampToValueAtTime(0.25, this.audioCtx.currentTime + 0.1);
                             gn.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + 1.5);
                             osc.start();
                             osc.stop(this.audioCtx.currentTime + 1.5);
                        }, 3000);

                    } else if (type === 'dialing') {
                        this.oscillator.type = 'sine';
                        this.oscillator.frequency.setValueAtTime(400, this.audioCtx.currentTime);
                        gainNode.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
                        this.oscillator.start();
                    }
                } catch (e) {
                    debugLog(`‚ùå Audio alert error: ${e.message}`, 'error');
                }
            }

            stopRing() {
                if (this.oscillator) {
                    try { this.oscillator.stop(); } catch(e) {}
                    this.oscillator = null;
                }
                if (this.ringInterval) {
                    clearInterval(this.ringInterval);
                    this.ringInterval = null;
                }
            }

            async getStream(audioOnly = false) {
                try {
                    const constraints = {
                        video: audioOnly ? false : {
                            width: { ideal: 1280, min: 640, max: 1920 },
                            height: { ideal: 720, min: 480, max: 1080 },
                            frameRate: { ideal: 30, min: 15 },
                            facingMode: 'user',
                            aspectRatio: 16/9
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            channelCount: { ideal: 1 },
                            sampleRate: { ideal: 48000 },
                            sampleSize: { ideal: 16 }
                        }
                    };

                    debugLog(`üìπ Requesting media (audioOnly: ${audioOnly})`);
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    stream.getTracks().forEach(track => {
                        track.onended = () => {
                            debugLog(`üõë Track ended: ${track.kind}`, 'warn');
                            if (State.callState === CallState.CONNECTED) {
                                App.ui.toast(`${track.kind} track ended`, 'warning');
                            }
                        };
                        track.onmute = () => debugLog(`üîá Track muted: ${track.kind}`, 'info');
                        track.onunmute = () => debugLog(`üîä Track unmuted: ${track.kind}`, 'info');
                    });

                    State.localStream = stream;
                    document.getElementById('local-video').srcObject = stream;
                    this.updateCallControls();
                    debugLog("‚úÖ Media stream granted");
                    
                    return stream;
                } catch (e) {
                    debugLog(`‚ùå Media error: ${e.name}`, 'error');
                    
                    const errorMessages = {
                        'NotAllowedError': "Permission denied! Allow camera/microphone access",
                        'NotFoundError': "No camera/microphone found",
                        'NotReadableError': "Device is already in use",
                        'SecurityError': "HTTPS required for secure context",
                        'OverconstrainedError': "Device doesn't support requested quality",
                        'AbortError': "Media request was cancelled"
                    };
                    
                    App.ui.toast(errorMessages[e.name] || "Media access failed", 'error');
                    throw e;
                }
            }

            // CORRECTED: PROPER INCOMING CALL HANDLER
            handleIncomingCall(call) {
                if (State.callState !== CallState.IDLE) {
                    debugLog("üìû Busy - rejecting incoming call");
                    call.close();
                    App.ui.toast("Missed call (busy)", 'warning');
                    return;
                }
                
                State.callState = CallState.RECEIVING;
                State.tempCall = call;
                State.callStats.connectionAttempts++;
                
                // FIX: Properly extract caller info
                const callerRaw = call.peer?.split('_')[0] || 'Unknown';
                document.getElementById('caller-name').innerText = callerRaw;
                document.getElementById('caller-avatar').innerText = (callerRaw || '?')[0].toUpperCase();
                
                // FIX: Determine call type from metadata
                const isVideo = call.options?.metadata?.video !== false;
                document.getElementById('call-type').innerText = isVideo ? 'Video' : 'Voice';
                
                // Show incoming call modal
                this.dom.incomingModal.classList.add('show');
                this.playRing('incoming');
                debugLog("üìû Incoming call modal shown");
                
                // Auto-reject after 30 seconds
                State.callTimeout = setTimeout(() => {
                    if (State.callState === CallState.RECEIVING) {
                        this.rejectCall();
                        App.ui.toast("Call timed out", 'warning');
                    }
                }, 30000);
            }

            // CORRECTED: PROPER CALL ACCEPTANCE
            async acceptCall() {
                if (State.callState !== CallState.RECEIVING || !State.tempCall) {
                    debugLog("‚ùå Invalid accept call state", 'error');
                    return;
                }
                
                clearTimeout(State.callTimeout);
                this.stopRing();
                
                // FIX: Hide modal immediately
                this.dom.incomingModal.classList.remove('show');
                
                // FIX: Show call overlay for callee
                App.ui.openCallOverlay();
                
                try {
                    const isVideo = State.tempCall.options?.metadata?.video !== false;
                    const stream = await this.getStream(!isVideo);
                    
                    // FIX: Answer with proper metadata
                    State.tempCall.answer(stream, {
                        metadata: { video: isVideo },
                        sdpTransform: (sdp) => this.optimizeSDP(sdp)
                    });
                    
                    // FIX: Set up call events and assign to currentCall
                    this.setupCallEvents(State.tempCall, !isVideo);
                    State.currentCall = State.tempCall;
                    State.tempCall = null; // Clear temp call
                    
                    State.callState = CallState.CONNECTING;
                    this.dom.callStatus.innerText = 'Connecting...';
                    debugLog("üìû Call accepted, overlay opened");
                } catch (e) {
                    debugLog(`‚ùå Accept error: ${e.message}`, 'error');
                    State.callState = CallState.IDLE;
                    this.rejectCall();
                    App.ui.toast("Failed to accept call", 'error');
                    App.ui.closeCallOverlay();
                }
            }

            rejectCall() {
                if (State.callTimeout) {
                    clearTimeout(State.callTimeout);
                    State.callTimeout = null;
                }
                
                this.stopRing();
                this.dom.incomingModal.classList.remove('show');
                
                if (State.tempCall) {
                    try { State.tempCall.close(); } catch(e) {}
                    State.tempCall = null;
                }
                
                if (State.callState === CallState.RECEIVING) {
                    State.callState = CallState.IDLE;
                }
                
                debugLog("üìû Call rejected");
            }

            // CORRECTED: PROPER CALL START
            async startCall(audioOnly = false) {
                if (!State.activeContact) {
                    App.ui.toast("Select a contact first", 'warning');
                    return;
                }
                
                if (State.callState !== CallState.IDLE) {
                    App.ui.toast("Already in a call", 'warning');
                    return;
                }

                const contactDoc = await getDoc(doc(db, "users", State.activeContact.uid));
                const contactData = contactDoc.data();
                const targetPeerId = contactData?.peerId;
                
                if (!targetPeerId) {
                    App.ui.toast("Contact is offline or not ready", 'warning');
                    return;
                }

                debugLog(`üéØ Calling peer: ${targetPeerId}`);
                State.callStats.connectionAttempts++;

                try {
                    App.ui.toast("Starting call...", 'info');
                    const stream = await this.getStream(audioOnly);
                    
                    // FIX: Open overlay for caller
                    App.ui.openCallOverlay();
                    
                    State.callStats.startTime = Date.now();
                    State.callState = CallState.CONNECTING;

                    const call = this.peer.call(targetPeerId, stream, {
                        metadata: { video: !audioOnly },
                        sdpTransform: (sdp) => this.optimizeSDP(sdp)
                    });
                    
                    this.setupCallEvents(call, audioOnly);
                    State.currentCall = call;
                    debugLog("üìû Call initiated, overlay opened");
                } catch (e) {
                    debugLog(`‚ùå Start call error: ${e.message}`, 'error');
                    App.ui.toast("Failed to start call", 'error');
                    this.endCall();
                    App.ui.closeCallOverlay();
                }
            }

            optimizeSDP(sdp) {
                return sdp
                    .replace(/a=fmtp:.*\r\n/g, '')
                    .replace(/a=rtcp-fb:.*\r\n/g, '')
                    .replace(/a=rtcp:.*\r\n/g, '');
            }

            // CORRECTED: PROPER CALL EVENT SETUP
            setupCallEvents(call, audioOnly = false) {
                State.currentCall = call;
                State.reconnectionAttempts = 0;
                State.callStats.iceCandidates = 0;
                
                // Start monitoring stats
                this.startStatsMonitoring(call);
                
                // FIX: Connection state handling
                call.peerConnection.onconnectionstatechange = () => {
                    const state = call.peerConnection.connectionState;
                    debugLog(`üîó Connection state: ${state}`);
                    
                    switch(state) {
                        case 'connecting':
                            this.dom.callStatus.innerText = "Connecting...";
                            this.dom.callStatus.style.display = 'block';
                            break;
                        case 'connected':
                            this.stopRing();
                            State.callState = CallState.CONNECTED;
                            State.callStartTime = Date.now();
                            App.ui.showCallDuration(true);
                            this.dom.callStatus.innerText = "Connected";
                            this.dom.callStatus.style.display = 'none';
                            this.dom.connectionQuality.style.display = 'flex';
                            
                            App.ui.toast("‚úÖ Connected!", 'success');
                            
                            // Establish P2P data channel
                            this.establishDataConnection(call.peer);
                            break;
                        case 'disconnected':
                            App.ui.toast("Disconnected... Attempting to reconnect", 'warning');
                            if (State.callState === CallState.CONNECTED) {
                                setTimeout(() => {
                                    if (call.peerConnection.connectionState === 'disconnected') {
                                        this.endCall();
                                    }
                                }, 5000);
                            }
                            break;
                        case 'failed':
                            debugLog("‚ùå Connection failed", 'error');
                            App.ui.showCallError("Connection failed");
                            this.endCall();
                            break;
                    }
                };
                
                call.peerConnection.oniceconnectionstatechange = () => {
                    const iceState = call.peerConnection.iceConnectionState;
                    debugLog(`üßä ICE state: ${iceState}`);
                };
                
                call.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        State.callStats.iceCandidates++;
                        debugLog(`üßä ICE candidate #${State.callStats.iceCandidates}`);
                    }
                };
                
                call.peerConnection.ontrack = (event) => {
                    debugLog(`üéµ Track received: ${event.track.kind}`);
                };
                
                // FIX: Proper stream handling
                call.on('stream', (remoteStream) => {
                    debugLog("‚úÖ Remote stream received");
                    document.getElementById('remote-video').srcObject = remoteStream;
                    
                    const duration = Date.now() - State.callStats.startTime;
                    debugLog(`‚è±Ô∏è Call established in ${duration}ms, ${State.callStats.iceCandidates} ICE candidates`);
                });

                call.on('close', () => {
                    debugLog("üìû Call closed by remote peer");
                    this.endCall();
                });

                call.on('error', (err) => {
                    debugLog(`üìû Call error: ${err.message}`, 'error');
                    App.ui.showCallError(err.message);
                    this.endCall();
                });
            }

            startStatsMonitoring(call) {
                const monitor = async () => {
                    if (!call.peerConnection) return;
                    
                    try {
                        const stats = await call.peerConnection.getStats();
                        let packetsLost = 0, packetsReceived = 0, jitter = 0, rtt = 0;
                        
                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.mediaType === 'audio') {
                                packetsLost = report.packetsLost || 0;
                                packetsReceived = report.packetsReceived || 0;
                                jitter = report.jitter || 0;
                            }
                            if (report.type === 'remote-inbound-rtp') {
                                rtt = report.roundTripTime * 1000 || 0;
                            }
                        });
                        
                        App.ui.updateConnectionQuality({
                            packetsLost,
                            packetsReceived,
                            jitter,
                            rtt
                        });
                        
                        State.callStats.packetsLost = packetsLost;
                    } catch (e) {
                        debugLog(`‚ùå Stats monitoring error: ${e.message}`, 'error');
                    }
                };

                this.statsInterval = setInterval(monitor, 2000);
            }

            establishDataConnection(peerId) {
                if (State.dataConnection && State.dataConnection.open) {
                    debugLog("üîó Data connection already exists");
                    return;
                }

                State.dataConnection = this.peer.connect(peerId, {
                    reliable: true,
                    serialization: 'binary'
                });

                State.dataConnection.on('open', () => {
                    debugLog("üîó P2P data channel opened");
                    App.ui.toast("P2P file transfer ready", 'success');
                });

                State.dataConnection.on('data', (data) => {
                    if (data.type === 'file-chunk') {
                        App.chat.handleIncomingFile(data);
                    }
                });

                State.dataConnection.on('close', () => {
                    debugLog("üîó P2P data channel closed");
                    State.dataConnection = null;
                });

                State.dataConnection.on('error', (err) => {
                    debugLog(`‚ùå P2P data channel error: ${err.message}`, 'error');
                });
            }

            // CORRECTED: PROPER CALL END
            endCall() {
                if (State.callTimeout) {
                    clearTimeout(State.callTimeout);
                    State.callTimeout = null;
                }

                if (this.statsInterval) {
                    clearInterval(this.statsInterval);
                    this.statsInterval = null;
                }
                
                debugLog("üõë Ending call gracefully");
                App.ui.showCallDuration(false);
                this.stopRing();
                
                State.callState = CallState.ENDED;
                
                if (State.currentCall) {
                    try { State.currentCall.close(); } catch(e) {}
                    State.currentCall = null;
                }
                
                if (State.tempCall) {
                    try { State.tempCall.close(); } catch(e) {}
                    State.tempCall = null;
                }
                
                this.stopAllStreams();
                
                if (State.dataConnection) {
                    try { State.dataConnection.close(); } catch(e) {}
                    State.dataConnection = null;
                }
                
                // FIX: Close overlay and reset UI
                App.ui.closeCallOverlay();
                document.getElementById('remote-video').srcObject = null;
                document.getElementById('local-video').srcObject = null;
                document.getElementById('local-video').style.transform = '';
                
                this.updateCallControls();
                
                // Reset state
                State.callState = CallState.IDLE;
                State.callStats = { 
                    startTime: null, 
                    iceCandidates: 0, 
                    connectionAttempts: 0,
                    bytesSent: 0,
                    bytesReceived: 0,
                    packetsLost: 0
                };
            }

            stopAllStreams() {
                if (State.localStream) {
                    State.localStream.getTracks().forEach(t => {
                        try { 
                            t.stop(); 
                            t.onended = null;
                            t.onmute = null;
                            t.onunmute = null;
                        } catch(e) {}
                    });
                    State.localStream = null;
                }

                if (State.screenStream) {
                    State.screenStream.getTracks().forEach(t => {
                        try { 
                            t.stop();
                            t.onended = null;
                        } catch(e) {}
                    });
                    State.screenStream = null;
                    State.isScreenSharing = false;
                }
            }

            toggleAudio() {
                if (!State.localStream) return;
                
                const track = State.localStream.getAudioTracks()[0];
                if (track) {
                    track.enabled = !track.enabled;
                    State.isMuted = !track.enabled;
                    this.updateCallControls();
                    debugLog(`üé§ Audio ${track.enabled ? 'enabled' : 'muted'}`);
                    
                    const muteBtn = document.getElementById('btn-mute');
                    muteBtn.style.background = track.enabled ? 'rgba(255,255,255,0.2)' : 'var(--danger)';
                    muteBtn.innerHTML = track.enabled ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
                }
            }

            toggleVideo() {
                if (!State.localStream) return;
                
                const track = State.localStream.getVideoTracks()[0];
                if (track) {
                    track.enabled = !track.enabled;
                    State.isVideoOff = !track.enabled;
                    this.updateCallControls();
                    debugLog(`üìπ Video ${track.enabled ? 'enabled' : 'disabled'}`);
                }
            }

            async toggleScreenShare() {
                if (!State.currentCall) {
                    App.ui.toast("No active call", 'warning');
                    return;
                }

                if (!State.isScreenSharing) {
                    try {
                        const screenStream = await navigator.mediaDevices.getDisplayMedia({
                            video: { cursor: 'always' },
                            audio: true
                        });

                        const screenTrack = screenStream.getVideoTracks()[0];
                        const sender = State.currentCall.peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );

                        if (sender) {
                            await sender.replaceTrack(screenTrack);
                        }

                        State.screenStream = screenStream;
                        State.isScreenSharing = true;
                        
                        const btn = document.getElementById('btn-screen');
                        btn.style.background = 'var(--primary)';
                        btn.classList.add('active');
                        
                        App.ui.toast("Screen sharing started", 'success');
                        debugLog("üñ•Ô∏è Screen sharing started");

                        screenTrack.onended = () => this.toggleScreenShare();

                    } catch (e) {
                        debugLog(`‚ùå Screen share error: ${e.message}`, 'error');
                        App.ui.toast("Screen sharing failed", 'error');
                    }
                } else {
                    if (State.screenStream) {
                        State.screenStream.getTracks().forEach(t => t.stop());
                        State.screenStream = null;
                    }

                    try {
                        const cameraStream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            }
                        });

                        const cameraTrack = cameraStream.getVideoTracks()[0];
                        const sender = State.currentCall.peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );

                        if (sender) {
                            await sender.replaceTrack(cameraTrack);
                        }

                        const audioTrack = State.localStream.getAudioTracks()[0];
                        State.localStream = new MediaStream([audioTrack, cameraTrack]);
                        document.getElementById('local-video').srcObject = State.localStream;

                        State.isScreenSharing = false;
                        
                        const btn = document.getElementById('btn-screen');
                        btn.style.background = 'rgba(255,255,255,0.2)';
                        btn.classList.remove('active');
                        
                        App.ui.toast("Screen sharing stopped", 'info');
                        debugLog("üñ•Ô∏è Screen sharing stopped");

                    } catch (e) {
                        debugLog(`‚ùå Camera restore error: ${e.message}`, 'error');
                    }
                }
            }

            updateCallControls() {
                if (!State.localStream) return;
                
                const audioTrack = State.localStream.getAudioTracks()[0];
                const videoTrack = State.localStream.getVideoTracks()[0];
                
                const muteBtn = document.getElementById('btn-mute');
                const camBtn = document.getElementById('btn-cam');
                
                if (audioTrack) {
                    muteBtn.style.background = audioTrack.enabled ? 'rgba(255,255,255,0.2)' : 'var(--danger)';
                    muteBtn.innerHTML = audioTrack.enabled ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
                }
                
                if (videoTrack) {
                    camBtn.style.background = videoTrack.enabled ? 'rgba(255,255,255,0.2)' : 'var(--danger)';
                    camBtn.innerHTML = videoTrack.enabled ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
                }
            }

            async flipCamera() {
                if (!State.localStream || !State.currentCall) {
                    App.ui.toast("Must be in call", 'warning');
                    return;
                }
                
                const videoTrack = State.localStream.getVideoTracks()[0];
                if (!videoTrack) return;
                
                const currentSettings = videoTrack.getSettings();
                const isFront = currentSettings.facingMode === 'user' || !currentSettings.facingMode;
                const newMode = isFront ? 'environment' : 'user';
                
                try {
                    App.ui.setLoading(true);
                    App.ui.toast("Switching camera...", 'info');
                    
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: newMode,
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        },
                        audio: false
                    });
                    
                    const newVideoTrack = newStream.getVideoTracks()[0];
                    const sender = State.currentCall.peerConnection.getSenders().find(s => 
                        s.track && s.track.kind === 'video'
                    );
                    
                    if (sender) {
                        await sender.replaceTrack(newVideoTrack);
                    }
                    
                    videoTrack.stop();
                    
                    const audioTrack = State.localStream.getAudioTracks()[0];
                    State.localStream = new MediaStream([audioTrack, newVideoTrack]);
                    document.getElementById('local-video').srcObject = State.localStream;
                    
                    App.ui.setLoading(false);
                    App.ui.toast("‚úÖ Camera switched", 'success');
                    debugLog("‚úÖ Camera switched");
                } catch (e) {
                    App.ui.setLoading(false);
                    App.ui.toast("Cannot switch camera", 'error');
                    debugLog(`‚ùå Flip camera error: ${e.message}`, 'error');
                }
            }

            handleDataConnection(connection) {
                connection.on('open', () => {
                    debugLog("üîó P2P data channel opened");
                    State.dataConnection = connection;
                });

                connection.on('data', (data) => {
                    if (data.type === 'file-chunk') {
                        App.chat.handleIncomingFile(data);
                    }
                });

                connection.on('close', () => {
                    debugLog("üîó P2P data channel closed");
                    State.dataConnection = null;
                });

                connection.on('error', (err) => {
                    debugLog(`‚ùå P2P data channel error: ${err.message}`, 'error');
                });
            }
        }

        const App = {
            auth: new AuthService(),
            chat: new ChatService(),
            call: new CallService(),
            ui: new UIManager(),
            contacts: null
        };

        App.contacts = App.chat;
        window.App = App;

        // Browser capability checks
        const browserChecks = () => {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                App.ui.toast("‚ùå Browser doesn't support WebRTC", 'error');
                return false;
            }
            return true;
        };

        if (!browserChecks()) {
            App.ui.toast("‚ùå Browser not supported", 'error');
        }

        // HTTPS check
        if (location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(location.hostname)) {
            App.ui.toast("‚ö†Ô∏è HTTPS REQUIRED for WebRTC!", 'error');
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                debugLog(`üîÑ Auth state: User ${user.uid} authenticated`);
                try {
                    const userDoc = await getDoc(doc(db, "users", user.uid));
                    if (userDoc.exists()) {
                        State.user = userDoc.data();
                        App.ui.showApp();
                        await App.chat.loadContacts();
                        App.call.init();
                        debugLog("‚úÖ Application fully loaded");
                    } else {
                        debugLog("‚ùå User document not found", 'error');
                        App.ui.toast("User data not found", 'error');
                        await signOut(auth);
                    }
                } catch (e) {
                    debugLog(`‚ùå Auth state error: ${e.message}`, 'error');
                    App.ui.toast("Failed to load user data", 'error');
                }
            } else {
                debugLog("üîÑ Auth state: No user");
                State.user = null;
                App.ui.showAuth();
            }
        });

        window.addEventListener('error', (event) => {
            debugLog(`‚ùå Global error: ${event.message} at ${event.filename}:${event.lineno}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            debugLog(`‚ùå Unhandled promise rejection: ${event.reason}`, 'error');
        });

        window.addEventListener('beforeunload', () => {
            debugLog("üßπ Cleaning up resources...");
            
            if (State.callState !== CallState.IDLE) {
                App.call.endCall();
            }
            
            if (State.peer) {
                try { State.peer.destroy(); } catch(e) {}
            }
            
            if (App.call.statsInterval) {
                clearInterval(App.call.statsInterval);
            }
            
            debugLog("‚úÖ Cleanup complete");
        });

        debugLog("üöÄ P2P Messenger initialized successfully");

    </script>
</body>
</html>
