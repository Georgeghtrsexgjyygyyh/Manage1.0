<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>FamilyChat Pro | Secure Messenger</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <style>
        /* --- 1. CORE VARIABLES & RESET --- */
        :root {
            --primary: #00a884;
            --primary-dark: #008f6f;
            --bg-main: #d1d7db;
            --bg-panel: #ffffff;
            --bg-chat: #efeae2;
            --text-main: #111b21;
            --text-sub: #667781;
            --incoming: #ffffff;
            --outgoing: #d9fdd3;
            --danger: #ef5350;
            --success: #25d366;
            --shadow-card: 0 4px 18px rgba(0,0,0,0.1);
            --header-height: 60px;
            --sidebar-width: 380px;
        }

        [data-theme="dark"] {
            --primary: #00a884;
            --primary-dark: #02906f;
            --bg-main: #0b141a;
            --bg-panel: #202c33;
            --bg-chat: #0b141a;
            --text-main: #e9edef;
            --text-sub: #8696a0;
            --incoming: #202c33;
            --outgoing: #005c4b;
            --shadow-card: 0 4px 18px rgba(0,0,0,0.3);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; height: 100dvh; background-color: var(--bg-main); color: var(--text-main); overflow: hidden; }
        
        button { border: none; outline: none; cursor: pointer; transition: all 0.2s; font-family: inherit; }
        input { font-family: inherit; outline: none; }
        
        /* --- 2. LAYOUT UTILITIES --- */
        .app-wrapper { display: flex; width: 100%; height: 100%; max-width: 1600px; margin: 0 auto; position: relative; background: var(--bg-panel); overflow: hidden; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .center { align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        .scroll-y { overflow-y: auto; scrollbar-width: thin; }

        /* --- 3. AUTH SCREEN --- */
        #auth-view { position: absolute; inset: 0; z-index: 2000; background: var(--bg-main); display: flex; align-items: center; justify-content: center; padding: 20px; }
        .auth-card { background: var(--bg-panel); width: 100%; max-width: 450px; padding: 40px; border-radius: 12px; box-shadow: var(--shadow-card); text-align: center; }
        .auth-logo { width: 80px; height: 80px; background: var(--primary); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 32px; margin: 0 auto 20px; }
        .auth-input { width: 100%; padding: 15px; margin-bottom: 15px; border: 1px solid var(--text-sub); border-radius: 8px; font-size: 16px; background: var(--bg-panel); color: var(--text-main); }
        .btn-primary { width: 100%; padding: 15px; background: var(--primary); color: white; border-radius: 8px; font-weight: 600; font-size: 16px; margin-top: 10px; position: relative; }
        .btn-primary:active { transform: scale(0.98); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; }
        .auth-switch { margin-top: 20px; color: var(--primary); cursor: pointer; font-size: 14px; }
        
        /* --- 4. SIDEBAR (CONTACTS) --- */
        aside { width: var(--sidebar-width); border-right: 1px solid rgba(0,0,0,0.1); display: flex; flex-direction: column; background: var(--bg-panel); z-index: 10; height: 100%; }
        .header { height: var(--header-height); padding: 0 16px; display: flex; align-items: center; justify-content: space-between; background: var(--bg-panel); border-bottom: 1px solid rgba(0,0,0,0.05); }
        .avatar { width: 40px; height: 40px; border-radius: 50%; background: var(--text-sub); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 18px; object-fit: cover; }
        
        .search-container { padding: 10px; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .search-box { background: rgba(0,0,0,0.05); border-radius: 8px; display: flex; align-items: center; padding: 0 10px; }
        .search-box input { border: none; background: transparent; padding: 10px; flex: 1; color: var(--text-main); }
        
        .contact-list { flex: 1; overflow-y: auto; }
        .contact-item { display: flex; align-items: center; padding: 12px 16px; cursor: pointer; transition: background 0.2s; position: relative; }
        .contact-item:hover { background: rgba(0,0,0,0.03); }
        .contact-item.active { background: rgba(0,0,0,0.06); }
        .contact-info { margin-left: 15px; flex: 1; overflow: hidden; }
        .contact-name { font-weight: 500; font-size: 17px; margin-bottom: 2px; }
        .contact-status { font-size: 13px; color: var(--text-sub); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .unread-badge { background: var(--success); color: white; font-size: 12px; padding: 2px 6px; border-radius: 10px; margin-left: auto; }

        /* --- 5. CHAT AREA --- */
        main { flex: 1; display: flex; flex-direction: column; background: var(--bg-chat); position: relative; height: 100%; }
        main::before { content: ""; position: absolute; inset: 0; opacity: 0.4; background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%239ca3af' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E"); pointer-events: none; }

        .chat-header { background: var(--bg-panel); height: var(--header-height); padding: 0 16px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid rgba(0,0,0,0.05); z-index: 5; }
        .chat-back-btn { display: none; margin-right: 15px; font-size: 20px; color: var(--text-main); }
        .chat-user-meta { display: flex; align-items: center; cursor: pointer; }
        .chat-actions i { font-size: 20px; color: var(--primary); margin-left: 25px; cursor: pointer; padding: 8px; border-radius: 50%; }
        .chat-actions i:hover { background: rgba(0,0,0,0.05); }

        .messages-container { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px; z-index: 2; }
        
        .msg { max-width: 65%; padding: 8px 12px; border-radius: 8px; font-size: 15px; line-height: 1.4; position: relative; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .msg-in { align-self: flex-start; background: var(--incoming); border-top-left-radius: 0; }
        .msg-out { align-self: flex-end; background: var(--outgoing); border-top-right-radius: 0; }
        .msg-time { font-size: 10px; color: var(--text-sub); text-align: right; margin-top: 4px; display: block; float: right; margin-left: 10px; }
        .msg-img { max-width: 100%; border-radius: 6px; margin-bottom: 4px; display: block; cursor: pointer; }

        .input-area { background: var(--bg-panel); padding: 10px 16px; display: flex; align-items: center; gap: 10px; z-index: 5; }
        .input-field { flex: 1; background: rgba(0,0,0,0.05); border-radius: 8px; padding: 12px; max-height: 100px; overflow-y: auto; color: var(--text-main); }
        .btn-icon { color: var(--text-sub); font-size: 22px; padding: 8px; display: flex; align-items: center; justify-content: center; }
        .btn-send { color: var(--primary); }

        /* --- 6. VIDEO CALL OVERLAY --- */
        #call-overlay { position: fixed; inset: 0; background: #000; z-index: 3000; display: flex; flex-direction: column; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #call-overlay.active { opacity: 1; pointer-events: auto; }
        
        .video-grid { flex: 1; position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        video { background: #000; }
        #remote-video { width: 100%; height: 100%; object-fit: contain; }
        #local-video { position: absolute; bottom: 100px; right: 20px; width: 120px; height: 160px; border-radius: 12px; border: 2px solid white; object-fit: cover; box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 3002; transition: all 0.3s; }
        
        .call-controls { position: absolute; bottom: 30px; left: 0; right: 0; display: flex; justify-content: center; gap: 20px; z-index: 3003; padding-bottom: env(safe-area-inset-bottom); }
        .ctrl-btn { width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.2); backdrop-filter: blur(10px); color: white; display: flex; align-items: center; justify-content: center; font-size: 24px; transition: 0.2s; }
        .ctrl-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.1); }
        .ctrl-btn.bg-red { background: var(--danger); }
        .ctrl-btn.active { background: white; color: #333; }

        .call-status-pill { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); padding: 8px 20px; border-radius: 30px; color: white; font-size: 14px; z-index: 3003; backdrop-filter: blur(5px); }

        /* --- 7. INCOMING CALL MODAL --- */
        #incoming-modal { position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-150%); background: rgba(32, 44, 51, 0.95); width: 90%; max-width: 400px; padding: 20px; border-radius: 16px; z-index: 4000; box-shadow: 0 10px 40px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: space-between; color: white; transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); backdrop-filter: blur(10px); }
        #incoming-modal.show { transform: translateX(-50%) translateY(0); }
        .incoming-info { display: flex; align-items: center; gap: 15px; }
        .incoming-actions { display: flex; gap: 15px; }
        .btn-accept { background: var(--success); width: 45px; height: 45px; border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; animation: pulse 1.5s infinite; }
        .btn-decline { background: var(--danger); width: 45px; height: 45px; border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(37, 211, 102, 0); } 100% { box-shadow: 0 0 0 0 rgba(37, 211, 102, 0); } }

        /* --- 8. MOBILE RESPONSIVE --- */
        @media (max-width: 768px) {
            .app-wrapper { border-radius: 0; box-shadow: none; }
            aside { width: 100%; position: absolute; }
            main { width: 100%; position: absolute; transform: translateX(100%); transition: transform 0.3s ease-in-out; z-index: 20; }
            
            body.chat-open aside { transform: translateX(-20%); opacity: 0; }
            body.chat-open main { transform: translateX(0); }
            
            .chat-back-btn { display: block; }
            
            #local-video { width: 90px; height: 130px; bottom: 120px; right: 15px; }
            .msg { font-size: 16px; }
        }

        /* --- 9. TOAST --- */
        #toast-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 5000; text-align: center; width: 100%; pointer-events: none; }
        .toast { display: inline-block; background: #333; color: white; padding: 12px 24px; border-radius: 30px; margin-top: 10px; opacity: 0; transition: 0.3s; transform: translateY(20px); font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .toast.visible { opacity: 1; transform: translateY(0); }

        /* --- 10. STATUS INDICATORS --- */
        .status-indicator { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-online { background: var(--success); }
        .status-offline { background: var(--text-sub); }
        .status-busy { background: var(--danger); }

        /* --- 11. DEBUG PANEL --- */
        #debug-panel { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.9); color: #0f0; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 11px; z-index: 9999; max-width: 350px; max-height: 200px; overflow-y: auto; display: none; }
        #debug-panel.show { display: block; }
    </style>
</head>
<body>

    <div id="debug-panel"></div>

    <div id="auth-view">
        <div class="auth-card">
            <div class="auth-logo"><i class="fas fa-users"></i></div>
            <h2 style="margin-bottom: 10px;">FamilyChat</h2>
            <p style="color: var(--text-sub); margin-bottom: 25px;">Connect with your loved ones</p>
            
            <div id="auth-error" style="color: var(--danger); font-size: 14px; margin-bottom: 15px; display: none;"></div>
            
            <input type="text" id="auth-nick" class="auth-input" placeholder="Your Nickname (e.g. Mom)" autocomplete="off">
            <input type="password" id="auth-pass" class="auth-input" placeholder="Password (min 6 chars)" autocomplete="new-password">
            
            <button id="btn-auth-action" class="btn-primary" onclick="App.auth.login()">
                <span id="auth-btn-text">Login</span>
                <span id="auth-loading" class="loading-spinner hidden"></span>
            </button>
            
            <div class="auth-switch" onclick="App.auth.toggleMode()">
                <span id="auth-switch-text">New here? Create Account</span>
            </div>
            
            <div style="margin-top: 20px; font-size: 12px; color: var(--text-sub);">
                ‚ö†Ô∏è Video calls require HTTPS or localhost<br>
                <button type="button" onclick="App.ui.toggleDebugPanel()" style="background: none; border: none; color: var(--primary); cursor: pointer; font-size: 12px;">
                    <i class="fas fa-bug"></i> Debug
                </button>
            </div>
        </div>
    </div>

    <div id="app-view" class="app-wrapper hidden">
        
        <aside>
            <div class="header">
                <div class="flex center" style="gap: 12px; cursor: pointer;" onclick="App.ui.showProfileSettings()">
                    <div id="my-avatar" class="avatar"></div>
                    <div class="flex flex-col">
                        <div style="font-weight: 600;" id="my-nick"></div>
                        <div style="font-size: 11px; color: var(--text-sub);">
                            <span class="status-indicator status-online"></span>Online
                        </div>
                    </div>
                </div>
                <div class="flex" style="gap: 15px;">
                    <button class="btn-icon" onclick="App.ui.toggleTheme()"><i class="fas fa-adjust"></i></button>
                    <button class="btn-icon" onclick="App.auth.logout()"><i class="fas fa-sign-out-alt"></i></button>
                </div>
            </div>
            
            <div class="search-container">
                <div class="search-box">
                    <i class="fas fa-search" style="color: var(--text-sub);"></i>
                    <input type="text" id="contact-search" placeholder="Search or add by nickname..." onkeyup="if(event.key === 'Enter') App.contacts.searchUser()">
                    <button onclick="App.contacts.searchUser()" style="padding: 8px; color: var(--primary); font-weight: bold;">ADD</button>
                </div>
            </div>

            <div id="contacts-list" class="contact-list">
                <div class="center flex flex-col" style="height: 100%; color: var(--text-sub); opacity: 0.6;">
                    <i class="fas fa-search" style="font-size: 32px; margin-bottom: 10px;"></i>
                    <p>Search for contacts to add</p>
                </div>
            </div>
        </aside>

        <main>
            <div class="chat-header">
                <div class="flex center">
                    <button class="chat-back-btn" onclick="App.ui.closeChat()"><i class="fas fa-arrow-left"></i></button>
                    <div class="chat-user-meta">
                        <div id="chat-avatar" class="avatar" style="width: 36px; height: 36px; margin-right: 10px; font-size: 14px;"></div>
                        <div>
                            <div id="chat-name" style="font-weight: 600; font-size: 16px;"></div>
                            <div id="chat-status" style="font-size: 12px; color: var(--text-sub);">
                                <span class="status-indicator status-offline"></span>Offline
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chat-actions flex">
                    <i class="fas fa-video" onclick="App.call.startCall()" title="Start video call"></i>
                    <i class="fas fa-phone" onclick="App.call.startCall(true)" title="Start audio call" style="margin-left: 15px;"></i>
                </div>
            </div>

            <div id="messages-area" class="messages-container">
                <div class="center flex flex-col" style="height: 100%; color: var(--text-sub); opacity: 0.6;">
                    <i class="fas fa-comments" style="font-size: 48px; margin-bottom: 20px;"></i>
                    <p>Select a contact to start chatting</p>
                </div>
            </div>

            <div id="input-area" class="input-area hidden">
                <button class="btn-icon" onclick="document.getElementById('file-upload').click()"><i class="fas fa-paperclip"></i></button>
                <input type="file" id="file-upload" hidden onchange="App.chat.handleFileUpload(this)">
                
                <input type="text" id="msg-input" class="input-field" placeholder="Type a message..." onkeydown="if(event.key === 'Enter') App.chat.sendMessage()">
                
                <button class="btn-icon btn-send" onclick="App.chat.sendMessage()"><i class="fas fa-paper-plane"></i></button>
            </div>
        </main>
    </div>

    <div id="incoming-modal">
        <div class="incoming-info">
            <div id="caller-avatar" class="avatar" style="background: white; color: #333;">?</div>
            <div>
                <div style="font-size: 12px; opacity: 0.8;">Incoming Video Call</div>
                <div id="caller-name" style="font-weight: bold; font-size: 18px;">Unknown</div>
            </div>
        </div>
        <div class="incoming-actions">
            <button class="btn-decline" onclick="App.call.rejectCall()"><i class="fas fa-times"></i></button>
            <button class="btn-accept" onclick="App.call.acceptCall()"><i class="fas fa-video"></i></button>
        </div>
    </div>

    <div id="call-overlay">
        <div class="call-status-pill" id="call-status-text">Preparing...</div>
        
        <div class="video-grid">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
        </div>

        <div class="call-controls">
            <button class="ctrl-btn" onclick="App.call.toggleAudio()" id="btn-mute" title="Toggle audio"><i class="fas fa-microphone"></i></button>
            <button class="ctrl-btn bg-red" onclick="App.call.endCall()" title="End call"><i class="fas fa-phone-slash"></i></button>
            <button class="ctrl-btn" onclick="App.call.toggleVideo()" id="btn-cam" title="Toggle video"><i class="fas fa-video"></i></button>
            <button class="ctrl-btn" onclick="App.call.flipCamera()" id="btn-flip" title="Switch camera"><i class="fas fa-camera-rotate"></i></button>
        </div>
    </div>

    <div id="toast-container"></div>

    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, onSnapshot, orderBy, serverTimestamp, doc, setDoc, getDoc, updateDoc, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";

        // --- FIREBASE CONFIG - –í–ê–ñ–ù–û: –ó–ê–ú–ï–ù–ò–¢–ï –ù–ê –í–ê–®–ò –î–ê–ù–ù–´–ï!!! ---
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyDXsvsaG8IdcjZv4iG4WHjPneGvcxywuTk",
  authDomain: "bobba-591c5.firebaseapp.com",
  projectId: "bobba-591c5",
  storageBucket: "bobba-591c5.firebasestorage.app",
  messagingSenderId: "839501020120",
  appId: "1:839501020120:web:0e58d4759785a1fadfd0ad",
  measurementId: "G-C3D5TB22F0"
};

        // Debug logger
        function debugLog(message, type = 'info') {
            const panel = document.getElementById('debug-panel');
            if (!panel.classList.contains('show')) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#f00' : type === 'success' ? '#0f0' : '#ff0';
            panel.innerHTML += `<div style="color:${color}">[${timestamp}] ${message}</div>`;
            panel.scrollTop = panel.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Initialize Firebase
        let app, auth, db, storage;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            storage = getStorage(app);
            debugLog("‚úÖ Firebase initialized successfully");
        } catch(e) {
            debugLog(`‚ùå Firebase init error: ${e.message}`, 'error');
            alert("Firebase initialization failed. Check config!");
        }

        /**
         * ------------------------------------------------------------------
         * CORE APPLICATION STATE & SERVICES
         * ------------------------------------------------------------------
         */

        const State = {
            user: null,
            activeContact: null,
            contactsMap: {},
            peer: null,
            currentCall: null,
            localStream: null,
            unsubscribeChat: null,
            isCalling: false,
            tempCall: null,
            callStats: { startTime: null, iceCandidates: 0 }
        };

        // --- UI MANAGER: Handles DOM manipulation, Themes, Toasts ---
        class UIManager {
            constructor() {
                this.dom = {
                    auth: document.getElementById('auth-view'),
                    app: document.getElementById('app-view'),
                    msgArea: document.getElementById('messages-area'),
                    inputArea: document.getElementById('input-area'),
                    contactList: document.getElementById('contacts-list'),
                    authLoading: document.getElementById('auth-loading'),
                    authBtnText: document.getElementById('auth-btn-text')
                };
            }

            toast(msg, type = 'info') {
                const container = document.getElementById('toast-container');
                const el = document.createElement('div');
                el.className = 'toast';
                el.textContent = msg;
                if(type === 'error') el.style.background = 'var(--danger)';
                if(type === 'success') el.style.background = 'var(--success)';
                if(type === 'warning') el.style.background = '#ff9800';
                container.appendChild(el);
                
                requestAnimationFrame(() => {
                    el.classList.add('visible');
                    setTimeout(() => {
                        el.classList.remove('visible');
                        setTimeout(() => el.remove(), 300);
                    }, 4000);
                });
            }

            setLoading(isLoading, element = null) {
                document.body.style.cursor = isLoading ? 'wait' : 'default';
                if(element) {
                    element.disabled = isLoading;
                }
                if(this.dom.authLoading) {
                    this.dom.authLoading.classList.toggle('hidden', !isLoading);
                }
            }

            toggleTheme() {
                const body = document.body;
                const current = body.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                body.setAttribute('data-theme', next);
                localStorage.setItem('theme', next);
                this.toast(`Theme changed to ${next}`, 'success');
            }

            initTheme() {
                const saved = localStorage.getItem('theme') || 'light';
                document.body.setAttribute('data-theme', saved);
            }

            showApp() {
                this.dom.auth.classList.add('hidden');
                this.dom.app.classList.remove('hidden');
                document.getElementById('my-nick').textContent = State.user.nickname;
                document.getElementById('my-avatar').textContent = State.user.nickname[0].toUpperCase();
                debugLog("‚úÖ App UI shown");
            }

            showAuth() {
                this.dom.app.classList.add('hidden');
                this.dom.auth.classList.remove('hidden');
            }

            openChatUI(contact) {
                document.body.classList.add('chat-open');
                document.getElementById('chat-name').textContent = contact.nickname;
                document.getElementById('chat-avatar').textContent = contact.nickname[0].toUpperCase();
                this.dom.inputArea.classList.remove('hidden');
                this.dom.msgArea.innerHTML = '';
                debugLog(`‚úÖ Chat opened with: ${contact.nickname}`);
            }

            closeChat() {
                document.body.classList.remove('chat-open');
                State.activeContact = null;
                if(State.unsubscribeChat) State.unsubscribeChat();
                debugLog("‚úÖ Chat closed");
            }

            showProfileSettings() {
                this.toast("Profile settings coming soon!");
            }

            toggleDebugPanel() {
                const panel = document.getElementById('debug-panel');
                panel.classList.toggle('show');
            }

            showCallError(message) {
                this.toast(`Call error: ${message}`, 'error');
                debugLog(`‚ùå Call error: ${message}`, 'error');
            }
        }

        // --- AUTH SERVICE: Login, Register, Logout ---
        class AuthService {
            constructor() {
                this.isRegistering = false;
            }

            toggleMode() {
                this.isRegistering = !this.isRegistering;
                const btnText = this.isRegistering ? 'Create Account' : 'Login';
                const switchText = this.isRegistering ? 'Have an account? Login' : 'New here? Create Account';
                
                document.getElementById('auth-btn-text').textContent = btnText;
                document.getElementById('auth-switch-text').textContent = switchText;
                document.getElementById('auth-error').style.display = 'none';
                
                debugLog(`Mode changed to: ${this.isRegistering ? 'register' : 'login'}`);
            }

            async login() {
                const nick = document.getElementById('auth-nick').value.trim();
                const pass = document.getElementById('auth-pass').value;

                if(!nick || !pass) {
                    this.showError("Please fill all fields");
                    return;
                }
                
                if(nick.length < 3) {
                    this.showError("Nickname must be at least 3 characters");
                    return;
                }
                
                if(pass.length < 6) {
                    this.showError("Password must be at least 6 characters");
                    return;
                }

                const email = this.generateEmail(nick);
                debugLog(`üìß Generated email: ${email}`);

                try {
                    App.ui.setLoading(true, document.getElementById('btn-auth-action'));
                    document.getElementById('auth-error').style.display = 'none';

                    if (this.isRegistering) {
                        debugLog("üîç Checking nickname availability...");
                        const q = query(collection(db, "users"), where("nickname", "==", nick));
                        const check = await getDocs(q);
                        
                        if (!check.empty) {
                            throw new Error("This nickname is already taken. Choose another one.");
                        }

                        debugLog("üë§ Creating Firebase Auth user...");
                        const cred = await createUserWithEmailAndPassword(auth, email, pass);
                        
                        debugLog("üìù Creating Firestore user document...");
                        await setDoc(doc(db, "users", cred.user.uid), {
                            uid: cred.user.uid,
                            nickname: nick,
                            email: email,
                            contacts: [],
                            createdAt: serverTimestamp()
                        });
                        
                        await updateProfile(cred.user, { displayName: nick });
                        debugLog("‚úÖ Registration successful!");
                    } else {
                        debugLog("üîê Signing in...");
                        await signInWithEmailAndPassword(auth, email, pass);
                        debugLog("‚úÖ Login successful!");
                    }
                } catch (e) {
                    debugLog(`‚ùå Auth error: ${e.code} - ${e.message}`, 'error');
                    this.handleAuthError(e);
                } finally {
                    App.ui.setLoading(false);
                }
            }

            generateEmail(nickname) {
                const sanitized = nickname.toLowerCase().replace(/[^a-z0-9]/g, '');
                return `${sanitized}@familychat.app`;
            }

            handleAuthError(error) {
                let userMessage = "Authentication failed";
                
                switch(error.code) {
                    case 'auth/network-request-failed':
                        userMessage = "Network error. Check internet connection and Firebase config.";
                        break;
                    case 'auth/invalid-email':
                        userMessage = "Invalid email format. Use only letters/numbers in nickname.";
                        break;
                    case 'auth/user-not-found':
                        userMessage = "Account not found. Create a new account.";
                        break;
                    case 'auth/wrong-password':
                        userMessage = "Wrong password. Try again.";
                        break;
                    case 'auth/email-already-in-use':
                        userMessage = "Nickname already registered.";
                        break;
                    case 'auth/too-many-requests':
                        userMessage = "Too many attempts. Try again later.";
                        break;
                    case 'auth/operation-not-allowed':
                        userMessage = "Email auth not enabled in Firebase Console.";
                        break;
                    case 'auth/api-key-not-valid':
                        userMessage = "Invalid Firebase API key. Check config.";
                        break;
                    default:
                        userMessage = error.message.replace("Firebase: ", "").substring(0, 100);
                }
                
                this.showError(userMessage);
            }

            showError(message) {
                const errDiv = document.getElementById('auth-error');
                errDiv.style.display = 'block';
                errDiv.textContent = message;
                debugLog(`‚ùå Auth error shown: ${message}`, 'error');
            }

            logout() {
                if(State.currentCall) {
                    debugLog("üìû Ending call before logout...");
                    App.call.endCall();
                }
                
                debugLog("üö™ Logging out...");
                signOut(auth).then(() => {
                    window.location.reload();
                }).catch(e => {
                    debugLog(`‚ùå Logout error: ${e.message}`, 'error');
                    App.ui.toast("Logout failed", 'error');
                });
            }
        }

        // --- CHAT & CONTACTS SERVICE ---
        class ChatService {
            constructor() {
                this.init();
            }

            init() {
                this.initVideoDrag();
            }

            initVideoDrag() {
                // ... (drag code remains same)
            }

            async loadContacts() {
                if(!State.user || !State.user.contacts) {
                    this.renderEmptyContactList();
                    return;
                }
                
                const list = document.getElementById('contacts-list');
                list.innerHTML = '';

                if(State.user.contacts.length === 0) {
                    this.renderEmptyContactList();
                    return;
                }

                const chunks = [];
                for (let i = 0; i < State.user.contacts.length; i += 10) {
                    chunks.push(State.user.contacts.slice(i, i + 10));
                }

                try {
                    for (const chunk of chunks) {
                        const q = query(collection(db, "users"), where("uid", "in", chunk));
                        const snap = await getDocs(q);
                        snap.forEach(d => {
                            const contact = d.data();
                            State.contactsMap[contact.uid] = contact;
                            this.renderContactItem(contact);
                        });
                    }
                    debugLog(`‚úÖ Loaded ${State.user.contacts.length} contacts`);
                } catch (e) {
                    debugLog(`‚ùå Load contacts error: ${e.message}`, 'error');
                    App.ui.toast("Error loading contacts", 'error');
                }
            }

            renderEmptyContactList() {
                const list = document.getElementById('contacts-list');
                list.innerHTML = '<div style="padding:20px; text-align:center; opacity:0.6;">Search for family members to add them!</div>';
            }

            renderContactItem(contact) {
                const list = document.getElementById('contacts-list');
                const div = document.createElement('div');
                div.className = 'contact-item';
                div.dataset.uid = contact.uid;
                div.innerHTML = `
                    <div class="avatar">${contact.nickname[0].toUpperCase()}</div>
                    <div class="contact-info">
                        <div class="contact-name">${contact.nickname}</div>
                        <div class="contact-status">Tap to chat</div>
                    </div>
                `;
                div.onclick = () => this.startChat(contact);
                list.appendChild(div);
            }

            async searchUser() {
                const input = document.getElementById('contact-search');
                const val = input.value.trim();
                
                if(!val) {
                    App.ui.toast("Enter a nickname to search", 'error');
                    return;
                }
                
                if(val === State.user.nickname) {
                    App.ui.toast("That's you!", 'error');
                    return;
                }

                App.ui.toast("Searching...");
                debugLog(`üîç Searching for user: ${val}`);
                
                try {
                    const q = query(collection(db, "users"), where("nickname", "==", val));
                    const snap = await getDocs(q);
                    
                    if(snap.empty) {
                        App.ui.toast("User not found", 'error');
                        debugLog("User not found");
                    } else {
                        const newUser = snap.docs[0].data();
                        await this.addContact(newUser);
                        input.value = '';
                    }
                } catch (e) {
                    debugLog(`‚ùå Search error: ${e.message}`, 'error');
                    App.ui.toast("Search failed", 'error');
                }
            }

            async addContact(newUser) {
                if(State.user.contacts.includes(newUser.uid)) {
                    App.ui.toast("Already in contacts");
                    return;
                }

                try {
                    const myRef = doc(db, "users", State.user.uid);
                    const updatedContacts = [...(State.user.contacts || []), newUser.uid];
                    
                    await updateDoc(myRef, { contacts: updatedContacts });
                    State.user.contacts = updatedContacts;
                    
                    State.contactsMap[newUser.uid] = newUser;
                    this.renderContactItem(newUser);
                    App.ui.toast("Added to contacts!", 'success');
                    debugLog(`‚úÖ Added contact: ${newUser.nickname}`);
                } catch (e) {
                    debugLog(`‚ùå Add contact error: ${e.message}`, 'error');
                    App.ui.toast("Failed to add contact", 'error');
                }
            }

            startChat(contact) {
                document.querySelectorAll('.contact-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-uid="${contact.uid}"]`)?.classList.add('active');

                State.activeContact = contact;
                App.ui.openChatUI(contact);

                const chatId = this.getChatId(State.user.uid, contact.uid);
                const q = query(collection(db, "chats", chatId, "messages"), orderBy("createdAt", "asc"));

                if(State.unsubscribeChat) State.unsubscribeChat();

                State.unsubscribeChat = onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            this.renderMessage(change.doc.data());
                        }
                    });
                }, (error) => {
                    debugLog(`‚ùå Chat listener error: ${error.message}`, 'error');
                    App.ui.toast("Error loading messages", 'error');
                });
            }

            getChatId(uid1, uid2) {
                return [uid1, uid2].sort().join("_");
            }

            renderMessage(msg) {
                const isMe = msg.senderId === State.user.uid;
                const div = document.createElement('div');
                div.className = `msg ${isMe ? 'msg-out' : 'msg-in'}`;
                
                let content = `<span>${this.escapeHtml(msg.text || '')}</span>`;
                
                if(msg.type === 'image' && msg.fileUrl) {
                    content = `<img src="${msg.fileUrl}" class="msg-img" onclick="window.open('${msg.fileUrl}')" alt="Image">` + content;
                } else if (msg.type === 'file' && msg.fileUrl) {
                    content = `<a href="${msg.fileUrl}" target="_blank" style="color:var(--primary); text-decoration:none;"><i class="fas fa-file"></i> ${this.escapeHtml(msg.text || 'File')}</a><br>` + content;
                }

                const date = msg.createdAt?.toDate ? msg.createdAt.toDate() : new Date();
                const time = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

                div.innerHTML = `${content} <span class="msg-time">${time}</span>`;
                
                const area = document.getElementById('messages-area');
                area.appendChild(div);
                area.scrollTop = area.scrollHeight;
                debugLog(`‚úÖ Message rendered: ${msg.text?.substring(0, 30)}...`);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            async sendMessage(fileData = null) {
                if(!State.activeContact) return;
                
                const input = document.getElementById('msg-input');
                const text = input.value.trim();
                
                if(!text && !fileData) return;

                const chatId = this.getChatId(State.user.uid, State.activeContact.uid);
                
                const payload = {
                    text: fileData ? (fileData.name || text) : text,
                    senderId: State.user.uid,
                    createdAt: serverTimestamp(),
                    type: fileData ? fileData.type : 'text',
                    fileUrl: fileData ? fileData.url : null
                };

                try {
                    debugLog(`üì§ Sending message to chat: ${chatId}`);
                    await addDoc(collection(db, "chats", chatId, "messages"), payload);
                    if(!fileData) input.value = '';
                    debugLog("‚úÖ Message sent");
                } catch (e) {
                    debugLog(`‚ùå Send message error: ${e.message}`, 'error');
                    App.ui.toast("Failed to send message", 'error');
                }
            }

            async handleFileUpload(input) {
                const file = input.files[0];
                if(!file) return;
                
                if(file.size > 10 * 1024 * 1024) {
                    App.ui.toast("File too large (max 10MB)", 'error');
                    input.value = '';
                    return;
                }

                App.ui.toast("Uploading...");
                App.ui.setLoading(true);
                
                try {
                    const storageRef = ref(storage, `chat/${Date.now()}_${file.name}`);
                    const snap = await uploadBytes(storageRef, file);
                    const url = await getDownloadURL(snap.ref);
                    const type = file.type.startsWith('image/') ? 'image' : 'file';
                    await this.sendMessage({ url, type, name: file.name });
                    App.ui.toast("File uploaded!", 'success');
                    debugLog("‚úÖ File uploaded successfully");
                } catch(e) {
                    debugLog(`‚ùå Upload error: ${e.message}`, 'error');
                    App.ui.toast("Upload failed", 'error');
                } finally {
                    App.ui.setLoading(false);
                    input.value = '';
                }
            }
        }

        // --- VIDEO CALL SERVICE (PeerJS + Web Audio API) ---
        class CallService {
            constructor() {
                this.audioCtx = null;
                this.oscillator = null;
                this.ringInterval = null;
                this.reconnectionAttempts = 0;
                this.maxReconnectionAttempts = 3;
                this.iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    // Free TURN server from OpenRelay (use with caution)
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ];
            }

            init() {
                const safeId = this.generatePeerId(State.user.nickname, State.user.uid);
                debugLog(`üé¨ Initializing PeerJS with ID: ${safeId}`);
                
                this.peer = new Peer(safeId, {
                    host: '0.peerjs.com',
                    port: 443,
                    secure: true,
                    debug: 3,
                    config: {
                        iceServers: this.iceServers,
                        iceCandidatePoolSize: 10
                    }
                });

                this.setupPeerEvents();
            }

            generatePeerId(nickname, uid) {
                const sanitized = nickname.replace(/[^a-zA-Z0-9]/g, '');
                return `${sanitized}_${uid.substring(0, 8)}`;
            }

            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    debugLog(`‚úÖ PeerJS connected: ${id}`);
                    App.ui.toast("Messenger ready", 'success');
                    this.reconnectionAttempts = 0;
                });

                this.peer.on('call', (call) => {
                    debugLog(`üìû Incoming call from: ${call.peer}`);
                    this.handleIncomingCall(call);
                });

                this.peer.on('error', (err) => {
                    debugLog(`‚ùå PeerJS Error: ${err.type} - ${err.message}`, 'error');
                    App.ui.toast(`Connection error: ${err.type}`, 'error');
                    this.handlePeerError(err);
                });

                this.peer.on('disconnected', () => {
                    debugLog("‚ö†Ô∏è Peer disconnected");
                    App.ui.toast("Connection lost. Reconnecting...", 'warning');
                    this.attemptReconnection();
                });
            }

            handlePeerError(err) {
                switch(err.type) {
                    case 'unavailable-id':
                        App.ui.toast("ID already in use. Please reload.", 'error');
                        break;
                    case 'network':
                        App.ui.toast("Network error. Check connection.", 'error');
                        break;
                    case 'server-error':
                        App.ui.toast("Server error. Please try again.", 'error');
                        break;
                    case 'browser-incompatible':
                        App.ui.toast("Browser not supported. Use Chrome/Edge.", 'error');
                        break;
                }
            }

            attemptReconnection() {
                if(this.reconnectionAttempts < this.maxReconnectionAttempts) {
                    this.reconnectionAttempts++;
                    debugLog(`üîÑ Reconnection attempt ${this.reconnectionAttempts}`);
                    setTimeout(() => {
                        this.peer.reconnect();
                    }, 2000 * this.reconnectionAttempts);
                } else {
                    App.ui.toast("Failed to reconnect. Please refresh.", 'error');
                }
            }

            playRing(type = 'incoming') {
                if (!this.audioCtx) {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                this.stopRing();

                this.oscillator = this.audioCtx.createOscillator();
                const gainNode = this.audioCtx.createGain();

                this.oscillator.connect(gainNode);
                gainNode.connect(this.audioCtx.destination);

                if (type === 'incoming') {
                    this.oscillator.type = 'sine';
                    this.oscillator.frequency.setValueAtTime(800, this.audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
                    
                    const now = this.audioCtx.currentTime;
                    gainNode.gain.linearRampToValueAtTime(0.3, now + 0.1);
                    gainNode.gain.linearRampToValueAtTime(0, now + 1.5);
                    
                    this.oscillator.start(now);
                    this.oscillator.stop(now + 1.5);
                    
                    this.ringInterval = setInterval(() => {
                         const osc = this.audioCtx.createOscillator();
                         const gn = this.audioCtx.createGain();
                         osc.connect(gn);
                         gn.connect(this.audioCtx.destination);
                         osc.frequency.setValueAtTime(800, this.audioCtx.currentTime);
                         gn.gain.setValueAtTime(0, this.audioCtx.currentTime);
                         gn.gain.linearRampToValueAtTime(0.3, this.audioCtx.currentTime + 0.1);
                         gn.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + 1.5);
                         osc.start();
                         osc.stop(this.audioCtx.currentTime + 1.5);
                    }, 3000);

                } else if (type === 'dialing') {
                    this.oscillator.type = 'sine';
                    this.oscillator.frequency.setValueAtTime(400, this.audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
                    this.oscillator.start();
                }
            }

            stopRing() {
                if (this.oscillator) {
                    try { 
                        this.oscillator.stop(); 
                    } catch(e) {}
                    this.oscillator = null;
                }
                if (this.ringInterval) {
                    clearInterval(this.ringInterval);
                    this.ringInterval = null;
                }
            }

            async getStream(audioOnly = false) {
                try {
                    const constraints = {
                        video: audioOnly ? false : {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user'
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    };

                    debugLog(`üìπ Getting user media (audioOnly: ${audioOnly})`);
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    State.localStream = stream;
                    document.getElementById('local-video').srcObject = stream;
                    
                    // Handle video element visibility
                    const localVideo = document.getElementById('local-video');
                    if(audioOnly) {
                        localVideo.style.display = 'none';
                    } else {
                        localVideo.style.display = 'block';
                    }
                    
                    this.updateCallControls();
                    debugLog("‚úÖ Media access granted");
                    
                    return stream;
                } catch (e) {
                    debugLog(`‚ùå Media access error: ${e.name} - ${e.message}`, 'error');
                    
                    let errorMsg = "Camera/mic access denied";
                    if(e.name === 'NotAllowedError') {
                        errorMsg = "Permission denied. Allow in browser settings.";
                    } else if(e.name === 'NotFoundError') {
                        errorMsg = "No camera/mic found.";
                    } else if(e.name === 'NotReadableError') {
                        errorMsg = "Device already in use.";
                    } else if(e.name === 'NotSupportedError') {
                        errorMsg = "Feature not supported on this device.";
                    } else if(e.name === 'SecurityError') {
                        errorMsg = "HTTPS required for camera/mic access!";
                    }
                    
                    App.ui.toast(errorMsg, 'error');
                    throw e;
                }
            }

            handleIncomingCall(call) {
                if (State.currentCall) {
                    debugLog("üìû Busy - rejecting incoming call");
                    call.close();
                    App.ui.toast("You missed a call (busy)", 'warning');
                    return;
                }
                
                this.tempCall = call;
                
                const callerRaw = call.peer.split('_')[0];
                document.getElementById('caller-name').innerText = callerRaw || 'Unknown';
                document.getElementById('caller-avatar').innerText = (callerRaw || '?')[0].toUpperCase();
                
                document.getElementById('incoming-modal').classList.add('show');
                this.playRing('incoming');
                debugLog("üìû Incoming call modal shown");
                
                setTimeout(() => {
                    if(this.tempCall && !State.currentCall) {
                        this.rejectCall();
                        App.ui.toast("Call timed out", 'warning');
                    }
                }, 30000);
            }

            async acceptCall() {
                if(!this.tempCall) return;
                
                this.stopRing();
                document.getElementById('incoming-modal').classList.remove('show');
                
                try {
                    const stream = await this.getStream();
                    this.tempCall.answer(stream);
                    this.setupCallEvents(this.tempCall);
                    App.ui.toast("Connecting...", 'info');
                    debugLog("üìû Call answered");
                } catch (e) {
                    debugLog(`‚ùå Accept call error: ${e.message}`, 'error');
                    this.rejectCall();
                    App.ui.toast("Failed to accept call", 'error');
                }
            }

            rejectCall() {
                this.stopRing();
                document.getElementById('incoming-modal').classList.remove('show');
                if(this.tempCall) {
                    this.tempCall.close();
                    this.tempCall = null;
                }
                debugLog("üìû Call rejected");
            }

            async startCall(audioOnly = false) {
                if(!State.activeContact) {
                    App.ui.toast("Select a contact first", 'error');
                    return;
                }
                
                if(State.currentCall) {
                    App.ui.toast("Already in a call", 'warning');
                    return;
                }

                const targetPeerId = this.generatePeerId(State.activeContact.nickname, State.activeContact.uid);
                debugLog(`üéØ Starting call to: ${targetPeerId} (audioOnly: ${audioOnly})`);

                try {
                    App.ui.toast("Initializing call...", 'info');
                    const stream = await this.getStream(audioOnly);
                    
                    document.getElementById('call-overlay').classList.add('active');
                    document.getElementById('call-status-text').innerText = "Dialing...";
                    document.getElementById('call-status-text').style.display = 'block';
                    this.playRing('dialing');
                    State.callStats.startTime = Date.now();

                    const call = this.peer.call(targetPeerId, stream);
                    this.setupCallEvents(call, audioOnly);

                } catch(e) {
                    debugLog(`‚ùå Start call error: ${e.message}`, 'error');
                    App.ui.toast("Failed to start call", 'error');
                    this.endCall();
                }
            }

            setupCallEvents(call, audioOnly = false) {
                State.currentCall = call;
                this.reconnectionAttempts = 0;
                
                // Monitor ICE candidates
                call.peerConnection.onicecandidate = (event) => {
                    if(event.candidate) {
                        State.callStats.iceCandidates++;
                        debugLog(`üßä ICE candidate ${State.callStats.iceCandidates}: ${event.candidate.candidate}`);
                    }
                };
                
                // Monitor connection state
                call.peerConnection.onconnectionstatechange = () => {
                    const state = call.peerConnection.connectionState;
                    debugLog(`üîó Connection state: ${state}`);
                    
                    if(state === 'connecting') {
                        document.getElementById('call-status-text').innerText = "Connecting...";
                    } else if(state === 'connected') {
                        document.getElementById('call-status-text').innerText = "Connected";
                        setTimeout(() => {
                            document.getElementById('call-status-text').style.display = 'none';
                        }, 3000);
                    } else if(state === 'disconnected') {
                        App.ui.toast("Connection lost...", 'warning');
                    } else if(state === 'failed') {
                        App.ui.showCallError("Connection failed");
                        this.endCall();
                    }
                };
                
                call.on('stream', (remoteStream) => {
                    debugLog("‚úÖ Remote stream received");
                    this.stopRing();
                    document.getElementById('remote-video').srcObject = remoteStream;
                    App.ui.toast("Call connected!", 'success');
                    
                    // Log call stats
                    const duration = Date.now() - State.callStats.startTime;
                    debugLog(`‚è±Ô∏è Call established in ${duration}ms, ICE candidates: ${State.callStats.iceCandidates}`);
                });

                call.on('close', () => {
                    debugLog("üìû Call closed by remote");
                    this.endCall();
                });

                call.on('error', (err) => {
                    debugLog(`üìû Call error: ${err.message}`, 'error');
                    App.ui.showCallError(err.message);
                });
            }

            endCall() {
                debugLog("üõë Ending call...");
                this.stopRing();
                
                if (State.currentCall) {
                    State.currentCall.close();
                    State.currentCall = null;
                }
                
                if (State.localStream) {
                    State.localStream.getTracks().forEach(t => {
                        try { t.stop(); } catch(e) {}
                    });
                    State.localStream = null;
                }
                
                document.getElementById('call-overlay').classList.remove('active');
                document.getElementById('remote-video').srcObject = null;
                document.getElementById('local-video').srcObject = null;
                document.getElementById('local-video').style.display = 'block';
                document.getElementById('call-status-text').style.display = 'block';
                document.getElementById('call-status-text').innerText = "Preparing...";
                
                this.updateCallControls();
                this.tempCall = null;
                State.callStats = { startTime: null, iceCandidates: 0 };
            }

            toggleAudio() {
                if(!State.localStream) return;
                const track = State.localStream.getAudioTracks()[0];
                if(track) {
                    track.enabled = !track.enabled;
                    this.updateCallControls();
                    debugLog(`üé§ Audio ${track.enabled ? 'enabled' : 'muted'}`);
                }
            }

            toggleVideo() {
                if(!State.localStream) return;
                const track = State.localStream.getVideoTracks()[0];
                if(track) {
                    track.enabled = !track.enabled;
                    this.updateCallControls();
                    debugLog(`üìπ Video ${track.enabled ? 'enabled' : 'disabled'}`);
                }
            }

            updateCallControls() {
                if(!State.localStream) return;
                
                const audioTrack = State.localStream.getAudioTracks()[0];
                const videoTrack = State.localStream.getVideoTracks()[0];
                
                const muteBtn = document.getElementById('btn-mute');
                const camBtn = document.getElementById('btn-cam');
                
                if(audioTrack) {
                    muteBtn.style.background = audioTrack.enabled ? 'rgba(255,255,255,0.2)' : 'var(--danger)';
                    muteBtn.innerHTML = audioTrack.enabled ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
                }
                
                if(videoTrack) {
                    camBtn.style.background = videoTrack.enabled ? 'rgba(255,255,255,0.2)' : 'var(--danger)';
                    camBtn.innerHTML = videoTrack.enabled ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
                }
            }

            async flipCamera() {
                if(!State.localStream || !State.currentCall) {
                    App.ui.toast("Must be in a call to switch camera", 'warning');
                    return;
                }
                
                const videoTrack = State.localStream.getVideoTracks()[0];
                if(!videoTrack) return;
                
                const currentSettings = videoTrack.getSettings();
                const isFront = currentSettings.facingMode === 'user';
                const newMode = isFront ? 'environment' : 'user';
                
                try {
                    App.ui.toast("Switching camera...", 'info');
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: newMode },
                        audio: true
                    });
                    
                    const newVideoTrack = newStream.getVideoTracks()[0];
                    const sender = State.currentCall.peerConnection.getSenders().find(s => 
                        s.track && s.track.kind === 'video'
                    );
                    
                    if(sender) {
                        await sender.replaceTrack(newVideoTrack);
                    }
                    
                    State.localStream.getVideoTracks().forEach(t => t.stop());
                    State.localStream = newStream;
                    document.getElementById('local-video').srcObject = newStream;
                    
                    App.ui.toast("Camera switched", 'success');
                    debugLog("‚úÖ Camera switched");
                } catch(e) {
                    App.ui.toast("Cannot switch camera", 'error');
                    debugLog(`‚ùå Flip camera error: ${e.message}`, 'error');
                }
            }
        }

        // --- MAIN APP INITIALIZATION ---
        const App = {
            auth: new AuthService(),
            chat: new ChatService(),
            call: new CallService(),
            ui: new UIManager(),
            contacts: null
        };

        App.contacts = App.chat;

        // Attach to window for HTML events
        window.App = App;

        // Validate Firebase config
        if(!firebaseConfig.apiKey || firebaseConfig.apiKey.includes('YOUR_')) {
            alert("‚ùå ERROR: You MUST replace firebaseConfig with your actual Firebase credentials!\n\nGet them from Firebase Console ‚Üí Project Settings ‚Üí General");
            debugLog("‚ùå Firebase config not set", 'error');
        }

        // Firebase Auth Listener
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                debugLog(`üîÑ Auth state: User ${user.uid} logged in`);
                try {
                    const userDoc = await getDoc(doc(db, "users", user.uid));
                    if(userDoc.exists()) {
                        State.user = userDoc.data();
                        App.ui.showApp();
                        await App.chat.loadContacts();
                        App.call.init();
                        App.ui.initTheme();
                        debugLog("‚úÖ App fully loaded");
                    } else {
                        debugLog("‚ùå User document not found", 'error');
                        App.ui.toast("User data not found", 'error');
                        await signOut(auth);
                    }
                } catch (e) {
                    debugLog(`‚ùå Auth state error: ${e.message}`, 'error');
                    App.ui.toast("Error loading user data", 'error');
                }
            } else {
                debugLog("üîÑ Auth state: No user");
                State.user = null;
                App.ui.showAuth();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            debugLog("üßπ Cleaning up before unload...");
            if(State.currentCall) App.call.endCall();
            if(State.peer) State.peer.destroy();
        });

        // Browser compatibility checks
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            App.ui.toast("‚ö†Ô∏è Your browser doesn't support video calls", 'error');
            debugLog("‚ùå getUserMedia not supported", 'error');
        }

        // Check for HTTPS
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            App.ui.toast("‚ö†Ô∏è HTTPS REQUIRED for video calls!", 'error');
            debugLog("‚ùå Not using HTTPS", 'error');
        }

        // Check for ad blockers
        setTimeout(() => {
            if(!auth) {
                App.ui.toast("‚ö†Ô∏è Firebase blocked by ad blocker?", 'error');
                debugLog("‚ùå Firebase auth not loaded", 'error');
            }
        }, 2000);

        // --- DEBUG PANEL CONTROLS ---
        window.toggleDebug = function() {
            App.ui.toggleDebugPanel();
        };
        
        debugLog("üöÄ Application initialized");

    </script>
</body>
</html>
