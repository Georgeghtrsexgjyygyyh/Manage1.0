<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#00a884">
    <meta name="description" content="FamilyChat Pro - Secure Family Messenger">
    <title>FamilyChat Pro | Secure Messenger</title>
    
    <!-- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ CDN –¥–ª—è –†–æ—Å—Å–∏–∏ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;600&display=swap">
    
    <script>
        // üîß –ö—ç—à–∏—Ä—É–µ–º critical —Ä–µ—Å—É—Ä—Å—ã –¥–ª—è –æ—Ñ–ª–∞–π–Ω-—Ä–∞–±–æ—Ç—ã
        if('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript,' + encodeURIComponent(`
                const CACHE = 'familychat-v1';
                const RESOURCES = [
                    'https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css',
                    'https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js',
                    'https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;600&display=swap'
                ];
                self.addEventListener('install', e => e.waitUntil(caches.open(CACHE).then(c => c.addAll(RESOURCES))));
                self.addEventListener('fetch', e => e.respondWith(caches.match(e.request).then(r => r || fetch(e.request))));
            `)).catch(() => console.log('SW registration skipped'));
        }
    </script>

    <style>
        /* --- –û–°–ù–û–í–ù–´–ï –°–¢–ò–õ–ò –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô --- */
        :root {
            --primary: #00a884;
            --primary-dark: #008f6f;
            --bg-main: #d1d7db;
            --bg-panel: #ffffff;
            --bg-chat: #efeae2;
            --text-main: #111b21;
            --text-sub: #667781;
            --incoming: #ffffff;
            --outgoing: #d9fdd3;
            --danger: #ef5350;
            --success: #25d366;
            --shadow-card: 0 4px 18px rgba(0,0,0,0.1);
            --header-height: 60px;
            --sidebar-width: 380px;
        }

        [data-theme="dark"] {
            --primary: #00a884;
            --primary-dark: #02906f;
            --bg-main: #0b141a;
            --bg-panel: #202c33;
            --bg-chat: #0b141a;
            --text-main: #e9edef;
            --text-sub: #8696a0;
            --incoming: #202c33;
            --outgoing: #005c4b;
            --shadow-card: 0 4px 18px rgba(0,0,0,0.3);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; height: 100dvh; background-color: var(--bg-main); color: var(--text-main); overflow: hidden; }
        button { border: none; outline: none; cursor: pointer; transition: all 0.2s; font-family: inherit; }
        input { font-family: inherit; outline: none; }
        
        .app-wrapper { display: flex; width: 100%; height: 100%; max-width: 1600px; margin: 0 auto; position: relative; background: var(--bg-panel); overflow: hidden; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .center { align-items: center; justify-content: center; }
        .hidden { display: none !important; }
        .scroll-y { overflow-y: auto; scrollbar-width: thin; }

        /* --- –ò–ù–î–ò–ö–ê–¢–û–† –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–Ø --- */
        #connection-status {
            position: fixed; top: 10px; right: 10px; z-index: 9999;
            padding: 8px 16px; border-radius: 20px; font-size: 12px;
            background: rgba(0,0,0,0.7); color: white;
            backdrop-filter: blur(10px);
        }
        #connection-status.online { background: var(--success); }
        #connection-status.offline { background: var(--danger); }
        #connection-status.connecting { background: #ff9800; }

        /* --- –°–¢–ò–õ–ò –ê–í–¢–û–†–ò–ó–ê–¶–ò–ò --- */
        #auth-view { position: absolute; inset: 0; z-index: 2000; background: var(--bg-main); display: flex; align-items: center; justify-content: center; padding: 20px; }
        .auth-card { background: var(--bg-panel); width: 100%; max-width: 450px; padding: 40px; border-radius: 12px; box-shadow: var(--shadow-card); text-align: center; }
        .auth-logo { width: 80px; height: 80px; background: var(--primary); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 32px; margin: 0 auto 20px; }
        .auth-input { width: 100%; padding: 15px; margin-bottom: 15px; border: 1px solid var(--text-sub); border-radius: 8px; font-size: 16px; background: var(--bg-panel); color: var(--text-main); }
        .btn-primary { width: 100%; padding: 15px; background: var(--primary); color: white; border-radius: 8px; font-weight: 600; font-size: 16px; margin-top: 10px; }
        .btn-primary:active { transform: scale(0.98); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; }
        .auth-switch { margin-top: 20px; color: var(--primary); cursor: pointer; font-size: 14px; }

        /* --- –°–ü–ò–°–û–ö –ö–û–ù–¢–ê–ö–¢–û–í --- */
        aside { width: var(--sidebar-width); border-right: 1px solid rgba(0,0,0,0.1); display: flex; flex-direction: column; background: var(--bg-panel); z-index: 10; height: 100%; }
        .header { height: var(--header-height); padding: 0 16px; display: flex; align-items: center; justify-content: space-between; background: var(--bg-panel); border-bottom: 1px solid rgba(0,0,0,0.05); }
        .avatar { width: 40px; height: 40px; border-radius: 50%; background: var(--text-sub); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 18px; object-fit: cover; }
        
        .search-container { padding: 10px; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .search-box { background: rgba(0,0,0,0.05); border-radius: 8px; display: flex; align-items: center; padding: 0 10px; }
        .search-box input { border: none; background: transparent; padding: 10px; flex: 1; color: var(--text-main); }
        
        .contact-list { flex: 1; overflow-y: auto; }
        .contact-item { display: flex; align-items: center; padding: 12px 16px; cursor: pointer; transition: background 0.2s; position: relative; }
        .contact-item:hover { background: rgba(0,0,0,0.03); }
        .contact-item.active { background: rgba(0,0,0,0.06); }
        .contact-info { margin-left: 15px; flex: 1; overflow: hidden; }
        .contact-name { font-weight: 500; font-size: 17px; margin-bottom: 2px; }
        .contact-status { font-size: 13px; color: var(--text-sub); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .unread-badge { background: var(--success); color: white; font-size: 12px; padding: 2px 6px; border-radius: 10px; margin-left: auto; }

        /* --- –ß–ê–¢ --- */
        main { flex: 1; display: flex; flex-direction: column; background: var(--bg-chat); position: relative; height: 100%; }
        main::before { content: ""; position: absolute; inset: 0; opacity: 0.4; background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%239ca3af' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E"); pointer-events: none; }

        .chat-header { background: var(--bg-panel); height: var(--header-height); padding: 0 16px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid rgba(0,0,0,0.05); z-index: 5; }
        .chat-back-btn { display: none; margin-right: 15px; font-size: 20px; color: var(--text-main); }
        .chat-user-meta { display: flex; align-items: center; cursor: pointer; }
        .chat-actions i { font-size: 20px; color: var(--primary); margin-left: 25px; cursor: pointer; padding: 8px; border-radius: 50%; }
        .chat-actions i:hover { background: rgba(0,0,0,0.05); }

        .messages-container { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px; z-index: 2; }
        .msg { max-width: 65%; padding: 8px 12px; border-radius: 8px; font-size: 15px; line-height: 1.4; position: relative; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .msg-in { align-self: flex-start; background: var(--incoming); border-top-left-radius: 0; }
        .msg-out { align-self: flex-end; background: var(--outgoing); border-top-right-radius: 0; }
        .msg-time { font-size: 10px; color: var(--text-sub); text-align: right; margin-top: 4px; display: block; float: right; margin-left: 10px; }
        .msg-img { max-width: 100%; border-radius: 6px; margin-bottom: 4px; display: block; cursor: pointer; }

        .input-area { background: var(--bg-panel); padding: 10px 16px; display: flex; align-items: center; gap: 10px; z-index: 5; }
        .input-field { flex: 1; background: rgba(0,0,0,0.05); border-radius: 8px; padding: 12px; max-height: 100px; overflow-y: auto; color: var(--text-main); border: none; }
        .btn-icon { color: var(--text-sub); font-size: 22px; padding: 8px; display: flex; align-items: center; justify-content: center; background: none; }
        .btn-send { color: var(--primary); }

        /* --- –í–ò–î–ï–û–ó–í–û–ù–ö–ò --- */
        #call-overlay { position: fixed; inset: 0; background: #000; z-index: 3000; display: flex; flex-direction: column; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #call-overlay.active { opacity: 1; pointer-events: auto; }
        .video-grid { flex: 1; position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        video { background: #000; width: 100%; height: 100%; object-fit: cover; }
        #remote-video { width: 100%; height: 100%; object-fit: contain; }
        #local-video { position: absolute; bottom: 100px; right: 20px; width: 120px; height: 160px; border-radius: 12px; border: 2px solid white; object-fit: cover; box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 3002; transition: all 0.3s; }
        #local-video.dragging { opacity: 0.8; }
        .call-controls { position: absolute; bottom: 30px; left: 0; right: 0; display: flex; justify-content: center; gap: 20px; z-index: 3003; padding-bottom: env(safe-area-inset-bottom); }
        .ctrl-btn { width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.2); backdrop-filter: blur(10px); color: white; display: flex; align-items: center; justify-content: center; font-size: 24px; transition: 0.2s; }
        .ctrl-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.1); }
        .ctrl-btn.bg-red { background: var(--danger); }
        .ctrl-btn.active { background: white; color: #333; }

        .call-status-pill { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); padding: 8px 20px; border-radius: 30px; color: white; font-size: 14px; z-index: 3003; backdrop-filter: blur(5px); }
        .call-duration { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); color: white; font-size: 14px; z-index: 3003; background: rgba(0,0,0,0.5); padding: 4px 12px; border-radius: 20px; display: none; }

        /* --- –ú–û–î–ê–õ –í–•–û–î–Ø–©–ï–ì–û –ó–í–û–ù–ö–ê --- */
        #incoming-modal { position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-150%); background: rgba(32, 44, 51, 0.95); width: 90%; max-width: 400px; padding: 20px; border-radius: 16px; z-index: 4000; box-shadow: 0 10px 40px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: space-between; color: white; transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); backdrop-filter: blur(10px); }
        #incoming-modal.show { transform: translateX(-50%) translateY(0); }
        .incoming-info { display: flex; align-items: center; gap: 15px; }
        .incoming-actions { display: flex; gap: 15px; }
        .btn-accept { background: var(--success); width: 45px; height: 45px; border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; animation: pulse 1.5s infinite; }
        .btn-decline { background: var(--danger); width: 45px; height: 45px; border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(37, 211, 102, 0); } 100% { box-shadow: 0 0 0 0 rgba(37, 211, 102, 0); } }

        /* --- –ú–û–ë–ò–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø --- */
        @media (max-width: 768px) {
            .app-wrapper { border-radius: 0; box-shadow: none; }
            aside { width: 100%; position: absolute; }
            main { width: 100%; position: absolute; transform: translateX(100%); transition: transform 0.3s ease-in-out; z-index: 20; }
            body.chat-open aside { transform: translateX(-20%); opacity: 0; }
            body.chat-open main { transform: translateX(0); }
            .chat-back-btn { display: block; }
            #local-video { width: 90px; height: 130px; bottom: 120px; right: 15px; }
            .msg { font-size: 16px; }
        }

        /* --- –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø --- */
        #toast-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 5000; text-align: center; width: 100%; pointer-events: none; }
        .toast { display: inline-block; background: #333; color: white; padding: 12px 24px; border-radius: 30px; margin-top: 10px; opacity: 0; transition: 0.3s; transform: translateY(20px); font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .toast.visible { opacity: 1; transform: translateY(0); }

        /* --- –ò–ù–î–ò–ö–ê–¢–û–† –ó–ê–ì–†–£–ó–ö–ò --- */
        .loader { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: white; animation: spin 1s ease-in-out infinite; margin-left: 10px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- –ú–û–î–ê–õ –ù–ê–°–¢–†–û–ï–ö --- */
        .settings-modal {
            position: fixed; inset: 0; z-index: 5000; background: rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
        }
        .settings-card {
            background: var(--bg-panel); padding: 30px; border-radius: 16px;
            max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
        }
        .settings-card h3 { margin-bottom: 20px; color: var(--text-main); }
        .settings-row { margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; }
        .toggle-switch { position: relative; width: 50px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; inset: 0; background: #ccc; border-radius: 24px; transition: 0.4s; }
        .toggle-slider:before { content: ""; position: absolute; height: 18px; width: 18px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: 0.4s; }
        input:checked + .toggle-slider { background: var(--primary); }
        input:checked + .toggle-slider:before { transform: translateX(26px); }
    </style>
</head>
<body>

    <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è -->
    <div id="connection-status" class="connecting">Connecting...</div>

    <!-- –ê–í–¢–û–†–ò–ó–ê–¶–ò–Ø -->
    <div id="auth-view">
        <div class="auth-card">
            <div class="auth-logo"><i class="fas fa-users"></i></div>
            <h2 style="margin-bottom: 10px;">FamilyChat Pro</h2>
            <p style="color: var(--text-sub); margin-bottom: 25px;">Connect with your loved ones</p>
            
            <div id="auth-error" style="color: var(--danger); font-size: 14px; margin-bottom: 15px; display: none;"></div>
            
            <input type="text" id="auth-nick" class="auth-input" placeholder="Your Nickname (e.g. Mom)" autocomplete="off" maxlength="20">
            <input type="password" id="auth-pass" class="auth-input" placeholder="Password (min 6 characters)" autocomplete="new-password" minlength="6">
            
            <button id="btn-auth-action" class="btn-primary" onclick="App.auth.login()">
                <span id="auth-btn-text">Login</span>
                <span class="loader hidden" id="auth-loader"></span>
            </button>
            
            <div class="auth-switch" onclick="App.auth.toggleMode()">
                <span id="auth-switch-text">New here? Create Account</span>
            </div>
        </div>
    </div>

    <!-- –ì–õ–ê–í–ù–û–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–ï -->
    <div id="app-view" class="app-wrapper hidden">
        
        <aside>
            <div class="header">
                <div class="flex center" style="gap: 12px; cursor: pointer;" onclick="App.ui.showProfileSettings()">
                    <div id="my-avatar" class="avatar"></div>
                    <div style="font-weight: 600;" id="my-nick"></div>
                </div>
                <div class="flex" style="gap: 15px;">
                    <button class="btn-icon" onclick="App.ui.toggleTheme()"><i class="fas fa-adjust"></i></button>
                    <button class="btn-icon" onclick="App.auth.logout()"><i class="fas fa-sign-out-alt"></i></button>
                </div>
            </div>
            
            <div class="search-container">
                <div class="search-box">
                    <i class="fas fa-search" style="color: var(--text-sub);"></i>
                    <input type="text" id="contact-search" placeholder="Search or add by nickname..." onkeyup="if(event.key === 'Enter') App.contacts.searchUser()">
                    <button onclick="App.contacts.searchUser()" style="padding: 8px; color: var(--primary); font-weight: bold;">ADD</button>
                </div>
            </div>

            <div id="contacts-list" class="contact-list"></div>
        </aside>

        <main>
            <div class="chat-header">
                <div class="flex center">
                    <button class="chat-back-btn" onclick="App.ui.closeChat()"><i class="fas fa-arrow-left"></i></button>
                    <div class="chat-user-meta">
                        <div id="chat-avatar" class="avatar" style="width: 36px; height: 36px; margin-right: 10px; font-size: 14px;"></div>
                        <div>
                            <div id="chat-name" style="font-weight: 600; font-size: 16px;"></div>
                            <div id="chat-status" style="font-size: 12px; color: var(--text-sub);">Offline</div>
                        </div>
                    </div>
                </div>
                <div class="chat-actions flex">
                    <i class="fas fa-video" onclick="App.call.startCall()"></i>
                </div>
            </div>

            <div id="messages-area" class="messages-container">
                <div class="center flex flex-col" style="height: 100%; color: var(--text-sub); opacity: 0.6;">
                    <i class="fas fa-comments" style="font-size: 48px; margin-bottom: 20px;"></i>
                    <p>Select a contact to start chatting</p>
                </div>
            </div>

            <div id="input-area" class="input-area hidden">
                <button class="btn-icon" onclick="document.getElementById('file-upload').click()"><i class="fas fa-paperclip"></i></button>
                <input type="file" id="file-upload" hidden onchange="App.chat.handleFileUpload(this)" accept="image/*,.pdf,.doc,.docx,.txt">
                
                <input type="text" id="msg-input" class="input-field" placeholder="Type a message..." onkeydown="if(event.key === 'Enter') App.chat.sendMessage()">
                
                <button class="btn-icon btn-send" onclick="App.chat.sendMessage()"><i class="fas fa-paper-plane"></i></button>
            </div>
        </main>
    </div>

    <!-- –í–•–û–î–Ø–©–ò–ô –ó–í–û–ù–û–ö -->
    <div id="incoming-modal">
        <div class="incoming-info">
            <div id="caller-avatar" class="avatar" style="background: white; color: #333;">?</div>
            <div>
                <div style="font-size: 12px; opacity: 0.8;">Incoming Video Call</div>
                <div id="caller-name" style="font-weight: bold; font-size: 18px;">Unknown</div>
            </div>
        </div>
        <div class="incoming-actions">
            <button class="btn-decline" onclick="App.call.rejectCall()"><i class="fas fa-times"></i></button>
            <button class="btn-accept" onclick="App.call.acceptCall()"><i class="fas fa-video"></i></button>
        </div>
    </div>

    <!-- –í–ò–î–ï–û–ó–í–û–ù–û–ö -->
    <div id="call-overlay">
        <div class="call-status-pill" id="call-status-text">Connecting...</div>
        <div class="call-duration" id="call-duration"></div>
        
        <div class="video-grid">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
        </div>

        <div class="call-controls">
            <button class="ctrl-btn" onclick="App.call.toggleAudio()" id="btn-mute"><i class="fas fa-microphone"></i></button>
            <button class="ctrl-btn bg-red" onclick="App.call.endCall()"><i class="fas fa-phone-slash"></i></button>
            <button class="ctrl-btn" onclick="App.call.toggleVideo()" id="btn-cam"><i class="fas fa-video"></i></button>
            <button class="ctrl-btn" onclick="App.call.flipCamera()" id="btn-flip"><i class="fas fa-camera-rotate"></i></button>
        </div>
    </div>

    <!-- –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø -->
    <div id="toast-container"></div>

    <script>
        // üîß –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø FIREBASE (–ó–ê–ú–ï–ù–ò–¢–ï –ù–ê –í–ê–®–ò –î–ê–ù–ù–´–ï)
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyDXsvsaG8IdcjZv4iG4WHjPneGvcxywuTk",
  authDomain: "bobba-591c5.firebaseapp.com",
  projectId: "bobba-591c5",
  storageBucket: "bobba-591c5.firebasestorage.app",
  messagingSenderId: "839501020120",
  appId: "1:839501020120:web:0e58d4759785a1fadfd0ad",
  measurementId: "G-C3D5TB22F0"
};

        // üîß –†–ï–ó–ï–†–í–ù–´–ï CDN –î–õ–Ø –†–û–°–°–ò–ò –ò –î–†–£–ì–ò–• –°–¢–†–ê–ù
        const CDN_FALLBACKS = {
            firebase: [
                'https://www.gstatic.com/firebasejs/9.22.0',
                'https://cdn.jsdelivr.net/npm/firebase@9.22.0',
                'https://unpkg.com/firebase@9.22.0/dist'
            ],
            peerjs: [
                'https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js',
                'https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js'
            ]
        };
    </script>

    <!-- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–ø–æ—Å–æ–± –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª–µ–π -->
    <script type="module">
        // üîß –£–ë–ò–†–ê–ï–ú –ü–†–û–ë–ï–õ–´ –í URL
        let firebaseUrl = 'https://www.gstatic.com/firebasejs/9.22.0';
        let peerjsUrl = 'https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js';
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å CDN
        try {
            await fetch(firebaseUrl + '/firebase-app.js', { mode: 'no-cors', method: 'HEAD' });
        } catch(e) {
            console.log('Primary CDN unavailable, using fallback');
            firebaseUrl = 'https://cdn.jsdelivr.net/npm/firebase@9.22.0/dist/esm';
            peerjsUrl = 'https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js';
        }

        // üîß –î–ò–ù–ê–ú–ò–ß–ï–°–ö–ò–ô –ò–ú–ü–û–†–¢ –ú–û–î–£–õ–ï–ô
        const [{ initializeApp }, 
               { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile },
               { getFirestore, collection, addDoc, query, where, onSnapshot, orderBy, serverTimestamp, doc, setDoc, getDoc, updateDoc, getDocs },
               { getStorage, ref, uploadBytes, getDownloadURL }] = await Promise.all([
            import(firebaseUrl + '/firebase-app.js'),
            import(firebaseUrl + '/firebase-auth.js'),
            import(firebaseUrl + '/firebase-firestore.js'),
            import(firebaseUrl + '/firebase-storage.js')
        ]).catch(() => {
            App.ui.toast('Failed to load Firebase SDK. Try VPN or proxy.', 'error');
            throw new Error('Firebase SDK unavailable');
        });

        // üîß –ó–ê–ì–†–£–ó–ö–ê PEERJS
        if(!window.Peer) {
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = peerjsUrl;
                script.onload = resolve;
                script.onerror = () => {
                    // –ü—Ä–æ–±—É–µ–º –≤—Ç–æ—Ä–æ–π CDN
                    script.src = 'https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js';
                    script.onload = resolve;
                    script.onerror = () => reject(new Error('PeerJS unavailable'));
                };
                document.head.appendChild(script);
            });
        }

        // üîß –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        // üîß –î–õ–Ø –†–û–°–°–ò–ò: –ò–°–ü–û–õ–¨–ó–£–ï–ú –≠–ú–£–õ–Ø–¢–û–†–´ –ü–†–ò –ù–ï–û–ë–•–û–î–ò–ú–û–°–¢–ò
        if(location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
            // connectFirestoreEmulator(db, 'localhost', 8080);
            // connectAuthEmulator(auth, "http://localhost:9099");
            // connectStorageEmulator(storage, "localhost", 9199);
        }

        // üîß –ü–†–û–í–ï–†–ö–ê –°–û–ï–î–ò–ù–ï–ù–ò–Ø –° FIREBASE
        const checkFirebaseConnection = async () => {
            const status = document.getElementById('connection-status');
            try {
                await getDoc(doc(db, '.info/connected'));
                status.textContent = 'Online';
                status.className = 'online';
            } catch(e) {
                status.textContent = 'Offline';
                status.className = 'offline';
                App.ui.toast('Connection lost. Using offline mode.', 'warning');
            }
        };

        const State = {
            user: null,
            activeContact: null,
            contactsMap: {},
            peer: null,
            currentCall: null,
            localStream: null,
            unsubscribeChat: null,
            isCalling: false,
            callStartTime: null,
            callDurationInterval: null,
            tempCall: null,
            callTimeout: null,
            incomingTimeout: null,
            firebaseConnected: false
        };

        class UIManager {
            constructor() {
                this.dom = {
                    auth: document.getElementById('auth-view'),
                    app: document.getElementById('app-view'),
                    msgArea: document.getElementById('messages-area'),
                    inputArea: document.getElementById('input-area'),
                    contactList: document.getElementById('contacts-list')
                };
            }

            toast(msg, type = 'info') {
                const container = document.getElementById('toast-container');
                const el = document.createElement('div');
                el.className = 'toast';
                el.textContent = msg;
                if(type === 'error') el.style.background = 'var(--danger)';
                if(type === 'success') el.style.background = 'var(--success)';
                if(type === 'warning') el.style.background = '#ff9800';
                container.appendChild(el);
                requestAnimationFrame(() => {
                    el.classList.add('visible');
                    setTimeout(() => {
                        el.classList.remove('visible');
                        setTimeout(() => el.remove(), 300);
                    }, 4000);
                });
            }

            setLoading(isLoading, elementId = null) {
                if(elementId) {
                    const el = document.getElementById(elementId);
                    if(el) el.style.display = isLoading ? 'inline-block' : 'none';
                }
                const btn = document.getElementById('btn-auth-action');
                if(btn) btn.disabled = isLoading;
                document.body.style.cursor = isLoading ? 'wait' : 'default';
            }

            toggleTheme() {
                const body = document.body;
                const current = body.getAttribute('data-theme');
                const next = current === 'dark' ? 'light' : 'dark';
                body.setAttribute('data-theme', next);
                try { localStorage.setItem('theme', next); } catch(e) {}
            }

            initTheme() {
                try {
                    const saved = localStorage.getItem('theme') || 'light';
                    document.body.setAttribute('data-theme', saved);
                } catch(e) {}
            }

            showApp() {
                this.dom.auth.classList.add('hidden');
                this.dom.app.classList.remove('hidden');
                document.getElementById('my-nick').textContent = State.user.nickname;
                document.getElementById('my-avatar').textContent = State.user.nickname[0].toUpperCase();
                checkFirebaseConnection();
                setInterval(checkFirebaseConnection, 30000); // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫
            }

            showAuth() {
                this.dom.app.classList.add('hidden');
                this.dom.auth.classList.remove('hidden');
            }

            openChatUI(contact) {
                document.body.classList.add('chat-open');
                document.getElementById('chat-name').textContent = contact.nickname;
                document.getElementById('chat-avatar').textContent = contact.nickname[0].toUpperCase();
                this.dom.inputArea.classList.remove('hidden');
                this.dom.msgArea.innerHTML = '';
            }

            closeChat() {
                document.body.classList.remove('chat-open');
                State.activeContact = null;
                if(State.unsubscribeChat) {
                    State.unsubscribeChat();
                    State.unsubscribeChat = null;
                }
            }

            showProfileSettings() {
                const modal = document.createElement('div');
                modal.className = 'settings-modal';
                modal.innerHTML = `
                    <div class="settings-card">
                        <h3>‚öôÔ∏è Settings</h3>
                        <div class="settings-row">
                            <span>Dark Mode</span>
                            <label class="toggle-switch">
                                <input type="checkbox" ${document.body.getAttribute('data-theme') === 'dark' ? 'checked' : ''} onchange="App.ui.toggleTheme()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="settings-row">
                            <span>Sound Notifications</span>
                            <label class="toggle-switch">
                                <input type="checkbox" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="settings-row">
                            <span>Data Saver</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="data-saver">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <button class="btn-primary" onclick="this.parentElement.parentElement.remove()" style="margin-top: 20px;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                modal.onclick = (e) => { if(e.target === modal) modal.remove(); };
            }

            updateCallDuration() {
                if (!State.callStartTime) return;
                const elapsed = Math.floor((Date.now() - State.callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const durationEl = document.getElementById('call-duration');
                durationEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                durationEl.style.display = 'block';
            }
        }

        class AuthService {
            constructor() {
                this.isRegistering = false;
            }

            toggleMode() {
                this.isRegistering = !this.isRegistering;
                document.getElementById('auth-btn-text').textContent = this.isRegistering ? 'Create Account' : 'Login';
                document.getElementById('auth-switch-text').textContent = this.isRegistering ? 'Have an account? Login' : 'New here? Create Account';
                document.getElementById('auth-error').style.display = 'none';
                document.getElementById('auth-nick').placeholder = this.isRegistering ? 'Choose Nickname (unique)' : 'Your Nickname';
            }

            async login() {
                const nick = document.getElementById('auth-nick').value.trim();
                const pass = document.getElementById('auth-pass').value;
                
                if(!nick || !pass) {
                    this.showError("Please fill all fields");
                    return;
                }

                if(nick.length < 2) {
                    this.showError("Nickname must be at least 2 characters");
                    return;
                }

                if(this.isRegistering && pass.length < 6) {
                    this.showError("Password must be at least 6 characters");
                    return;
                }

                // üîß –≠–ú–£–õ–Ø–¶–ò–Ø EMAIL –î–õ–Ø FIREBASE
                const email = `user_${nick.toLowerCase().replace(/[^a-z0-9]/g, '')}_${Math.random().toString(36).substr(2, 9)}@familychat.app`;

                try {
                    App.ui.setLoading(true, 'auth-loader');
                    document.getElementById('auth-error').style.display = 'none';

                    if (this.isRegistering) {
                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω–∏–∫–Ω–µ–π–º–∞
                        const q = query(collection(db, "users"), where("nickname", "==", nick));
                        const check = await getDocs(q);
                        if (!check.empty) {
                            throw new Error("Nickname already taken. Try adding numbers.");
                        }

                        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                        const cred = await createUserWithEmailAndPassword(auth, email, pass);
                        
                        // –°–æ–∑–¥–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ Firestore
                        await setDoc(doc(db, "users", cred.user.uid), {
                            uid: cred.user.uid,
                            nickname: nick,
                            contacts: [],
                            createdAt: serverTimestamp(),
                            email: email // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
                        });
                        
                        await updateProfile(cred.user, { displayName: nick });
                        App.ui.toast("‚úÖ Account created successfully!", "success");
                    } else {
                        // üîß –ü–û–ò–°–ö –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø –ü–û –ù–ò–ö–ù–ï–ô–ú–£
                        const usersRef = collection(db, "users");
                        const q = query(usersRef, where("nickname", "==", nick));
                        const querySnapshot = await getDocs(q);
                        
                        if(querySnapshot.empty) {
                            throw new Error("User not found. Check nickname or create account.");
                        }
                        
                        const userData = querySnapshot.docs[0].data();
                        // –í—Ö–æ–¥ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ email
                        await signInWithEmailAndPassword(auth, userData.email, pass);
                    }
                } catch (e) {
                    console.error("Auth error:", e);
                    this.showError(e.message.replace("Firebase: ", "").replace("auth/", ""));
                } finally {
                    App.ui.setLoading(false, 'auth-loader');
                }
            }

            showError(message) {
                const errDiv = document.getElementById('auth-error');
                errDiv.style.display = 'block';
                errDiv.textContent = message;
            }

            logout() {
                if(App.call.peer) {
                    App.call.peer.destroy();
                }
                signOut(auth).then(() => {
                    window.location.reload();
                }).catch(e => {
                    console.error("Logout error:", e);
                    window.location.reload();
                });
            }
        }

        class ChatService {
            constructor() {
                this.messageQueue = []; // –û—á–µ—Ä–µ–¥—å –¥–ª—è –æ—Ñ–ª–∞–π–Ω —Å–æ–æ–±—â–µ–Ω–∏–π
                this.isOnline = false;
            }

            async loadContacts() {
                if(!State.user || !State.user.contacts) return;
                const list = document.getElementById('contacts-list');
                list.innerHTML = '';

                if(State.user.contacts.length === 0) {
                    list.innerHTML = '<div style="padding:20px; text-align:center; opacity:0.6;">Search for family members to add them!</div>';
                    return;
                }

                try {
                    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –±–∞—Ç—á–∞–º–∏
                    const chunks = [];
                    for (let i = 0; i < State.user.contacts.length; i += 10) {
                        chunks.push(State.user.contacts.slice(i, i + 10));
                    }

                    for (const chunk of chunks) {
                        const q = query(collection(db, "users"), where("uid", "in", chunk));
                        const snap = await getDocs(q);
                        snap.forEach(d => {
                            const contact = d.data();
                            State.contactsMap[contact.uid] = contact;
                            this.renderContactItem(contact);
                        });
                    }
                } catch (e) {
                    console.error("Error loading contacts:", e);
                    App.ui.toast("Offline mode: Showing cached contacts", "warning");
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–∑ –∫—ç—à–∞
                    Object.values(State.contactsMap).forEach(c => this.renderContactItem(c));
                }
            }

            renderContactItem(contact) {
                const list = document.getElementById('contacts-list');
                const existing = list.querySelector(`[data-uid="${contact.uid}"]`);
                if(existing) return;

                const div = document.createElement('div');
                div.className = 'contact-item';
                div.dataset.uid = contact.uid;
                div.innerHTML = `
                    <div class="avatar">${contact.nickname[0].toUpperCase()}</div>
                    <div class="contact-info">
                        <div class="contact-name">${contact.nickname}</div>
                        <div class="contact-status">Tap to chat</div>
                    </div>
                `;
                div.onclick = () => this.startChat(contact);
                list.appendChild(div);
            }

            async searchUser() {
                const input = document.getElementById('contact-search');
                const val = input.value.trim();
                
                if(!val) {
                    App.ui.toast("Enter a nickname to search", "error");
                    return;
                }
                
                if(val === State.user.nickname) {
                    App.ui.toast("That's you!", "error");
                    return;
                }

                App.ui.setLoading(true);
                App.ui.toast("Searching...");

                try {
                    const q = query(collection(db, "users"), where("nickname", "==", val));
                    const snap = await getDocs(q);
                    
                    if(snap.empty) {
                        App.ui.toast("User not found", "error");
                    } else {
                        const newUser = snap.docs[0].data();
                        if(newUser.uid === State.user.uid) {
                            App.ui.toast("That's you!", "error");
                            return;
                        }
                        
                        const myRef = doc(db, "users", State.user.uid);
                        let current = State.user.contacts || [];
                        
                        if(!current.includes(newUser.uid)) {
                            current.push(newUser.uid);
                            await updateDoc(myRef, { contacts: current });
                            State.user.contacts = current;
                            this.renderContactItem(newUser);
                            State.contactsMap[newUser.uid] = newUser;
                            App.ui.toast(`‚úÖ Added ${newUser.nickname}`, "success");
                            input.value = '';
                        } else {
                            App.ui.toast("Already in contacts", "info");
                        }
                    }
                } catch (e) {
                    console.error("Search error:", e);
                    App.ui.toast("Search failed. Check connection.", "error");
                } finally {
                    App.ui.setLoading(false);
                }
            }

            startChat(contact) {
                State.activeContact = contact;
                App.ui.openChatUI(contact);

                document.querySelectorAll('.contact-item').forEach(item => {
                    item.classList.remove('active');
                    if(item.dataset.uid === contact.uid) {
                        item.classList.add('active');
                    }
                });

                const chatId = this.getChatId(State.user.uid, contact.uid);
                const q = query(collection(db, "chats", chatId, "messages"), orderBy("createdAt", "asc"));

                if(State.unsubscribeChat) {
                    State.unsubscribeChat();
                }

                State.unsubscribeChat = onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            this.renderMessage(change.doc.data());
                        }
                    });
                }, (error) => {
                    console.error("Chat snapshot error:", error);
                    App.ui.toast("Connection lost. Messages may be delayed.", "warning");
                });
            }

            getChatId(uid1, uid2) {
                return [uid1, uid2].sort().join("_");
            }

            renderMessage(msg) {
                const isMe = msg.senderId === State.user.uid;
                const div = document.createElement('div');
                div.className = `msg ${isMe ? 'msg-out' : 'msg-in'}`;
                
                let content = `<span>${msg.text || ''}</span>`;
                
                if(msg.type === 'image') {
                    content = `<img src="${msg.fileUrl}" class="msg-img" onclick="window.open('${msg.fileUrl}', '_blank')" alt="Image">` + content;
                } else if (msg.type === 'file') {
                    content = `<a href="${msg.fileUrl}" target="_blank" style="color:var(--primary); text-decoration:none;"><i class="fas fa-file"></i> File</a><br>` + content;
                }

                const date = msg.createdAt ? msg.createdAt.toDate() : new Date();
                const time = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

                div.innerHTML = `${content} <span class="msg-time">${time}</span>`;
                
                const area = document.getElementById('messages-area');
                area.appendChild(div);
                area.scrollTop = area.scrollHeight;
            }

            async sendMessage(fileData = null) {
                if(!State.activeContact) return;
                const input = document.getElementById('msg-input');
                const text = input.value.trim();
                
                if(!text && !fileData) return;

                const chatId = this.getChatId(State.user.uid, State.activeContact.uid);
                
                const payload = {
                    text: text,
                    senderId: State.user.uid,
                    createdAt: serverTimestamp(),
                    type: fileData ? fileData.type : 'text',
                    fileUrl: fileData ? fileData.url : null
                };

                try {
                    // üîß –°–û–•–†–ê–ù–Ø–ï–ú –í –û–ß–ï–†–ï–î–¨ –ü–†–ò –û–§–õ–ê–ô–ù–ï
                    if(!State.firebaseConnected) {
                        this.messageQueue.push(payload);
                        this.renderMessage({...payload, createdAt: new Date()});
                        input.value = '';
                        App.ui.toast("Offline: Message will be sent when online", "warning");
                        return;
                    }

                    await addDoc(collection(db, "chats", chatId, "messages"), payload);
                    input.value = '';
                } catch (e) {
                    console.error("Send error:", e);
                    App.ui.toast("Failed to send. Retrying...", "error");
                    // –ü–æ–º–µ—â–∞–µ–º –≤ –æ—á–µ—Ä–µ–¥—å –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
                    this.messageQueue.push(payload);
                }
            }

            async handleFileUpload(input) {
                const file = input.files[0];
                if(!file) return;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (max 10MB)
                if(file.size > 10 * 1024 * 1024) {
                    App.ui.toast("File too large. Max 10MB.", "error");
                    return;
                }

                App.ui.setLoading(true);
                App.ui.toast("Uploading... 0%");

                try {
                    const isImage = file.type.startsWith('image/');
                    const path = `chat/${State.user.uid}/${Date.now()}_${file.name.replace(/[^a-zA-Z0-9.]/g, '_')}`;
                    const storageRef = ref(storage, path);
                    
                    // –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                    const uploadTask = uploadBytes(storageRef, file, {
                        cacheControl: 'public, max-age=31536000'
                    });

                    uploadTask.on('state_changed', (snapshot) => {
                        const progress = Math.round((snapshot.bytesTransferred / snapshot.totalBytes) * 100);
                        App.ui.toast(`Uploading... ${progress}%`, 'info');
                    });

                    await uploadTask;
                    const url = await getDownloadURL(storageRef);
                    
                    await this.sendMessage({ 
                        url, 
                        type: isImage ? 'image' : 'file' 
                    });
                    
                    App.ui.toast("‚úÖ File sent!", "success");
                } catch(e) {
                    console.error("Upload error:", e);
                    App.ui.toast("Upload failed. Check connection.", "error");
                } finally {
                    App.ui.setLoading(false);
                    input.value = '';
                }
            }

            // üîß –û–¢–ü–†–ê–í–ö–ê –û–ß–ï–†–ï–î–ò –°–û–û–ë–©–ï–ù–ò–ô –ü–†–ò –í–û–ó–í–†–ê–¢–ï –û–ù–õ–ê–ô–ù
            async flushMessageQueue() {
                if(this.messageQueue.length === 0) return;
                
                App.ui.toast(`Sending ${this.messageQueue.length} pending messages...`, 'info');
                
                for(const msg of this.messageQueue) {
                    try {
                        const chatId = this.getChatId(State.user.uid, State.activeContact.uid);
                        await addDoc(collection(db, "chats", chatId, "messages"), msg);
                    } catch(e) {
                        console.error("Failed to send queued message:", e);
                        App.ui.toast("Some messages failed to send", 'error');
                        return;
                    }
                }
                
                this.messageQueue = [];
                App.ui.toast("All pending messages sent!", 'success');
            }
        }

        class CallService {
            constructor() {
                this.audioCtx = null;
                this.oscillator = null;
                this.ringInterval = null;
            }

            init() {
                // üîß –ì–ï–ù–ï–†–ê–¶–ò–Ø –ë–ï–ó–û–ü–ê–°–ù–û–ì–û PEER ID
                const peerId = `fc_${State.user.uid}`;
                
                console.log("Initializing PeerJS with ID:", peerId);

                this.peer = new Peer(peerId, {
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.google.com:19302' },
                            // –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ TURN —Å–µ—Ä–≤–µ—Ä—ã –¥–ª—è –†–æ—Å—Å–∏–∏
                            { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
                            { urls: 'turn:freeturn.net:3478', username: 'free', credential: 'free' }
                        ],
                        iceCandidatePoolSize: 10,
                        iceTransportPolicy: 'all'
                    },
                    debug: 1 // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π debug
                });

                this.peer.on('open', (id) => {
                    console.log('‚úÖ Peer connected with ID:', id);
                    App.ui.toast("‚úÖ Ready for calls", "success");
                });

                this.peer.on('call', (call) => {
                    console.log("üìû Incoming call from:", call.peer);
                    this.handleIncomingCall(call);
                });

                this.peer.on('error', (err) => {
                    console.error('‚ùå PeerJS Error:', err);
                    App.ui.toast(`Connection Error: ${err.type}`, 'error');
                    this.endCall();
                });

                this.peer.on('disconnected', () => {
                    console.warn("‚ö†Ô∏è Peer disconnected, reconnecting...");
                    App.ui.toast("Connection lost. Reconnecting...", "warning");
                    setTimeout(() => this.peer.reconnect(), 3000);
                });
            }

            playRing(type = 'incoming') {
                try {
                    if (!this.audioCtx) {
                        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    this.stopRing();

                    this.oscillator = this.audioCtx.createOscillator();
                    const gainNode = this.audioCtx.createGain();

                    this.oscillator.connect(gainNode);
                    gainNode.connect(this.audioCtx.destination);

                    if (type === 'incoming') {
                        this.oscillator.type = 'sine';
                        this.oscillator.frequency.setValueAtTime(800, this.audioCtx.currentTime);
                        gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
                        
                        const now = this.audioCtx.currentTime;
                        gainNode.gain.linearRampToValueAtTime(0.5, now + 0.1);
                        gainNode.gain.linearRampToValueAtTime(0, now + 2);
                        
                        this.oscillator.start(now);
                        this.oscillator.stop(now + 2);
                        
                        this.ringInterval = setInterval(() => {
                             const osc = this.audioCtx.createOscillator();
                             const gn = this.audioCtx.createGain();
                             osc.connect(gn);
                             gn.connect(this.audioCtx.destination);
                             osc.frequency.setValueAtTime(800, this.audioCtx.currentTime);
                             gn.gain.setValueAtTime(0, this.audioCtx.currentTime);
                             gn.gain.linearRampToValueAtTime(0.5, this.audioCtx.currentTime + 0.1);
                             gn.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + 2);
                             osc.start();
                             osc.stop(this.audioCtx.currentTime + 2);
                        }, 3000);

                    } else if (type === 'dialing') {
                        this.oscillator.frequency.setValueAtTime(400, this.audioCtx.currentTime);
                        gainNode.gain.value = 0.1;
                        this.oscillator.start();
                    }
                } catch(e) {
                    console.log("Audio error:", e);
                }
            }

            stopRing() {
                if (this.oscillator) {
                    try { this.oscillator.stop(); } catch(e){}
                    this.oscillator = null;
                }
                if (this.ringInterval) {
                    clearInterval(this.ringInterval);
                    this.ringInterval = null;
                }
            }

            async getStream() {
                try {
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    const dataSaver = localStorage.getItem('data-saver') === 'true';
                    
                    const constraints = {
                        video: isMobile || dataSaver ? {
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            facingMode: 'user',
                            frameRate: { ideal: 24, max: 30 }
                        } : {
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 },
                            facingMode: 'user',
                            frameRate: { ideal: 30, max: 60 }
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 48000
                        }
                    };

                    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error("Camera/microphone not supported");
                    }

                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    State.localStream = stream;
                    
                    stream.getTracks().forEach(track => {
                        track.onended = () => {
                            console.log("Track ended:", track.kind);
                            if(State.currentCall) {
                                App.ui.toast(`${track.kind} device disconnected`, "warning");
                                if (track.kind === 'video') {
                                    this.replaceVideoTrack();
                                }
                            }
                        };
                    });

                    const localVideo = document.getElementById('local-video');
                    localVideo.srcObject = stream;
                    
                    return stream;
                } catch (e) {
                    console.error("Stream error:", e);
                    let errorMsg = "Camera access denied";
                    if(e.name === 'NotFoundError') errorMsg = "No camera/microphone found";
                    if(e.name === 'NotAllowedError') errorMsg = "Please allow camera access in browser settings";
                    if(e.name === 'OverconstrainedError') errorMsg = "Camera not supported";
                    if(e.name === 'NotReadableError') errorMsg = "Camera is busy";
                    
                    App.ui.toast(errorMsg, 'error');
                    throw e;
                }
            }

            handleIncomingCall(call) {
                if (State.currentCall) {
                    console.log("Busy, rejecting call");
                    call.close(); 
                    return;
                }
                
                State.tempCall = call;
                
                const callerUid = call.peer.replace('fc_', '');
                const callerContact = State.contactsMap[callerUid];
                const callerName = callerContact ? callerContact.nickname : 'Unknown';
                
                document.getElementById('caller-name').innerText = callerName;
                document.getElementById('caller-avatar').innerText = callerName[0]?.toUpperCase() || '?';
                
                document.getElementById('incoming-modal').classList.add('show');
                this.playRing('incoming');
                
                // –ê–≤—Ç–æ–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 30 —Å–µ–∫—É–Ω–¥
                State.incomingTimeout = setTimeout(() => {
                    if(State.tempCall) {
                        this.rejectCall();
                        App.ui.toast("Call missed", "warning");
                    }
                }, 30000);
            }

            async acceptCall() {
                clearTimeout(State.incomingTimeout);
                this.stopRing();
                document.getElementById('incoming-modal').classList.remove('show');
                
                try {
                    const stream = await this.getStream();
                    State.tempCall.answer(stream);
                    this.setupCallEvents(State.tempCall);
                    document.getElementById('call-overlay').classList.add('active');
                    document.getElementById('call-status-text').innerText = "Connecting...";
                    document.getElementById('call-status-text').style.display = 'block';
                    
                    App.ui.toast("‚úÖ Call accepted", "success");
                    State.tempCall = null;
                    
                } catch (e) {
                    console.error("Accept call error:", e);
                    this.rejectCall();
                    App.ui.toast("Failed to accept call", "error");
                }
            }

            rejectCall() {
                clearTimeout(State.incomingTimeout);
                this.stopRing();
                document.getElementById('incoming-modal').classList.remove('show');
                if(State.tempCall) {
                    State.tempCall.close();
                    State.tempCall = null;
                }
            }

            async startCall() {
                if(!State.activeContact) {
                    App.ui.toast("Select a contact first", "error");
                    return;
                }
                
                const targetPeerId = `fc_${State.activeContact.uid}`;
                console.log("Calling peer:", targetPeerId);

                try {
                    const stream = await this.getStream();
                    document.getElementById('call-overlay').classList.add('active');
                    document.getElementById('call-status-text').style.display = 'block';
                    document.getElementById('call-status-text').innerText = "Dialing...";
                    this.playRing('dialing');

                    const call = this.peer.call(targetPeerId, stream, {
                        metadata: {
                            callerName: State.user.nickname,
                            timestamp: Date.now()
                        }
                    });
                    
                    State.callTimeout = setTimeout(() => {
                        if(!State.currentCall) {
                            App.ui.toast("No answer", "warning");
                            this.endCall();
                        }
                    }, 30000);

                    this.setupCallEvents(call);

                } catch(e) {
                    console.error("Start call error:", e);
                    App.ui.toast("Failed to start call", "error");
                    this.endCall();
                }
            }

            setupCallEvents(call) {
                State.currentCall = call;
                State.callStartTime = Date.now();
                
                State.callDurationInterval = setInterval(() => {
                    App.ui.updateCallDuration();
                }, 1000);

                call.on('stream', (remoteStream) => {
                    clearTimeout(State.callTimeout);
                    this.stopRing();
                    document.getElementById('call-status-text').innerText = "Connected";
                    setTimeout(() => {
                        document.getElementById('call-status-text').style.display = 'none';
                    }, 2000);
                    
                    const remoteVideo = document.getElementById('remote-video');
                    remoteVideo.srcObject = remoteStream;
                    
                    remoteStream.getTracks().forEach(track => {
                        track.onended = () => {
                            console.log("Remote track ended");
                            App.ui.toast("Remote user disconnected", "warning");
                            this.endCall();
                        };
                    });
                });

                call.on('close', () => {
                    console.log("Call closed by remote");
                    this.endCall();
                });

                call.on('error', (err) => {
                    console.error("Call error:", err);
                    App.ui.toast("Call error occurred", "error");
                    this.endCall();
                });

                if(call.peerConnection) {
                    call.peerConnection.oniceconnectionstatechange = () => {
                        const iceState = call.peerConnection.iceConnectionState;
                        console.log("ICE state:", iceState);
                        
                        if(iceState === 'connected') {
                            App.ui.toast("‚úÖ Connected", "success");
                        } else if(iceState === 'failed') {
                            App.ui.toast("Connection failed. Try again.", "error");
                            this.endCall();
                        } else if(iceState === 'disconnected') {
                            App.ui.toast("Connection unstable", "warning");
                            setTimeout(() => {
                                if (call.peerConnection.iceConnectionState === 'disconnected') {
                                    this.endCall();
                                }
                            }, 5000);
                        }
                    };

                    call.peerConnection.onconnectionstatechange = () => {
                        if(call.peerConnection.connectionState === 'failed') {
                            App.ui.toast("Connection failed", "error");
                            this.endCall();
                        }
                    };
                }
            }

            endCall() {
                clearTimeout(State.callTimeout);
                clearTimeout(State.incomingTimeout);
                clearInterval(State.callDurationInterval);
                this.stopRing();
                
                if (State.currentCall) {
                    try { State.currentCall.close(); } catch(e) {}
                    State.currentCall = null;
                }
                
                if (State.tempCall) {
                    try { State.tempCall.close(); } catch(e) {}
                    State.tempCall = null;
                }
                
                if (State.localStream) {
                    State.localStream.getTracks().forEach(t => {
                        try { t.stop(); } catch(e) {}
                    });
                }
                
                State.localStream = null;
                State.callStartTime = null;
                
                document.getElementById('call-overlay').classList.remove('active');
                document.getElementById('remote-video').srcObject = null;
                document.getElementById('local-video').srcObject = null;
                document.getElementById('call-status-text').style.display = 'block';
                document.getElementById('call-duration').style.display = 'none';
                
                const muteBtn = document.getElementById('btn-mute');
                const camBtn = document.getElementById('btn-cam');
                if(muteBtn) {
                    muteBtn.style.background = 'rgba(255,255,255,0.2)';
                    muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                }
                if(camBtn) {
                    camBtn.style.background = 'rgba(255,255,255,0.2)';
                    camBtn.innerHTML = '<i class="fas fa-video"></i>';
                }
            }

            toggleAudio() {
                if(!State.localStream) return;
                const track = State.localStream.getAudioTracks()[0];
                if(!track) return;
                
                track.enabled = !track.enabled;
                const btn = document.getElementById('btn-mute');
                btn.style.background = track.enabled ? 'rgba(255,255,255,0.2)' : 'var(--danger)';
                btn.innerHTML = track.enabled ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
            }

            toggleVideo() {
                if(!State.localStream) return;
                const track = State.localStream.getVideoTracks()[0];
                if(!track) return;
                
                track.enabled = !track.enabled;
                const btn = document.getElementById('btn-cam');
                btn.style.background = track.enabled ? 'rgba(255,255,255,0.2)' : 'var(--danger)';
                btn.innerHTML = track.enabled ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
            }

            async flipCamera() {
                if(!State.localStream) return;
                
                const currentTrack = State.localStream.getVideoTracks()[0];
                const currentSettings = currentTrack?.getSettings() || {};
                const currentMode = currentSettings.facingMode || 'user';
                const newMode = currentMode === 'user' ? 'environment' : 'user';
                
                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: newMode },
                        audio: false
                    });
                    
                    const videoTrack = newStream.getVideoTracks()[0];
                    
                    if(State.localStream) {
                        const oldVideoTrack = State.localStream.getVideoTracks()[0];
                        if(oldVideoTrack) {
                            State.localStream.removeTrack(oldVideoTrack);
                            oldVideoTrack.stop();
                        }
                        State.localStream.addTrack(videoTrack);
                    }
                    
                    if(State.currentCall && State.currentCall.peerConnection) {
                        const sender = State.currentCall.peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                        if(sender) {
                            await sender.replaceTrack(videoTrack);
                        }
                    }
                    
                    const localVideo = document.getElementById('local-video');
                    localVideo.srcObject = State.localStream;
                    
                    App.ui.toast("Camera flipped", "success");
                    
                } catch(e) {
                    console.error("Camera switch error:", e);
                    App.ui.toast("Cannot switch camera", "error");
                }
            }

            async replaceVideoTrack() {
                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: false
                    });
                    
                    const videoTrack = newStream.getVideoTracks()[0];
                    
                    if(State.localStream) {
                        const oldVideoTrack = State.localStream.getVideoTracks()[0];
                        if(oldVideoTrack) {
                            State.localStream.removeTrack(oldVideoTrack);
                            oldVideoTrack.stop();
                        }
                        State.localStream.addTrack(videoTrack);
                    }
                    
                    if(State.currentCall && State.currentCall.peerConnection) {
                        const sender = State.currentCall.peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                        if(sender) {
                            await sender.replaceTrack(videoTrack);
                        }
                    }
                    
                    const localVideo = document.getElementById('local-video');
                    localVideo.srcObject = State.localStream;
                    
                } catch(e) {
                    console.error("Replace video track error:", e);
                }
            }
        }

        // –ì–ª–∞–≤–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        const App = {
            auth: new AuthService(),
            chat: new ChatService(),
            call: new CallService(),
            ui: new UIManager(),
            contacts: null
        };
        App.contacts = App.chat;

        window.App = App;

        // üîß –°–õ–ï–ñ–ï–ù–ò–ï –ó–ê –°–û–°–¢–û–Ø–ù–ò–ï–ú –°–û–ï–î–ò–ù–ï–ù–ò–Ø
        onSnapshot(doc(db, ".info/connected"), (snap) => {
            State.firebaseConnected = snap.data().connected;
            const status = document.getElementById('connection-status');
            if(State.firebaseConnected) {
                status.textContent = 'Online';
                status.className = 'online';
                App.chat.flushMessageQueue();
            } else {
                status.textContent = 'Offline';
                status.className = 'offline';
            }
        });

        // Firebase Auth Listener
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                try {
                    const userDoc = await getDoc(doc(db, "users", user.uid));
                    if(userDoc.exists()) {
                        State.user = userDoc.data();
                        App.ui.showApp();
                        await App.chat.loadContacts();
                        App.call.init();
                        App.ui.initTheme();
                    } else {
                        // –ï—Å–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ–º –µ–≥–æ
                        await setDoc(doc(db, "users", user.uid), {
                            uid: user.uid,
                            nickname: user.displayName || "User",
                            contacts: [],
                            createdAt: serverTimestamp(),
                            email: user.email
                        });
                        window.location.reload();
                    }
                } catch (e) {
                    console.error("Auth state error:", e);
                    App.ui.toast("Error loading user data", "error");
                }
            } else {
                State.user = null;
                App.ui.showAuth();
            }
        }, (error) => {
            console.error("Auth listener error:", error);
            App.ui.toast("Authentication error. Try refreshing.", "error");
        });

        // üîß –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö –ì–õ–û–ë–ê–õ–¨–ù–û
        window.addEventListener('error', (e) => {
            console.error("Global error:", e.error);
            App.ui.toast("An error occurred. Please refresh.", "error");
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error("Unhandled promise:", e.reason);
            App.ui.toast("Network error. Check connection.", "warning");
        });

        // üîß –ü–†–û–í–ï–†–ö–ê –ü–û–î–î–ï–†–ñ–ö–ò WebRTC
        window.addEventListener('load', () => {
            if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                App.ui.toast("‚ö†Ô∏è Your browser doesn't support video calls", "warning");
                document.querySelector('.fa-video').style.display = 'none';
            }
        });

        // üîß –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï –ü–û–°–õ–ï –ü–û–¢–ï–†–ò –§–û–ö–£–°–ê
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && State.user && !State.firebaseConnected) {
                checkFirebaseConnection();
            }
        });

        // üîß –û–ß–ò–°–¢–ö–ê –ü–†–ò –ó–ê–ö–†–´–¢–ò–ò –í–ö–õ–ê–î–ö–ò
        window.addEventListener('beforeunload', () => {
            if(State.currentCall) {
                App.call.endCall();
            }
        });
    </script>
</body>
</html>
